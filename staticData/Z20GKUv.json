{"module":{"contents":{"data":{"layout":"lesson","title":"Reduce","permalink":"/reduce/"}},"title":"Array Reduce","path":"2-Working-With-Arrays/array-reduce","id":"array-reduce","body":"<h2 id=\"sometimes-you-need-to-turn-an-array-of-numbers-into-just-one-big-number\">Sometimes you need to turn an array of numbers into just one big number</h2>\n<pre><code class=\"lang-js\">let soldItems = [\n  {productId: 1, price: 30.99},\n  {productId: 2, price: 12.99},\n  {productId: 3, price: 61.99},\n  {productId: 4, price: 17.99},\n  {productId: 5, price: 22.99},\n];\n\nlet totalSales = 0;\n\nfor(let i = 0; i &lt; soldItems.length; i++) {\n  totalSales += soldItems[i].price;\n}\n</code></pre>\n<h2 id=\"what-is-array-reduce-\">What is Array.reduce?</h2>\n<ul>\n<li>A functional programming tool found natively in javascript</li>\n<li>Creates <strong>any</strong> new data structure</li>\n<li>Does not modify the original array</li>\n</ul>\n<h2 id=\"how-does-it-work-\">How does it work?</h2>\n<ul>\n<li>With the same example as above</li>\n</ul>\n<pre><code class=\"lang-js\">const soldItems = [\n  {productId: 1, price: 30.99},\n  {productId: 2, price: 12.99},\n  {productId: 3, price: 61.99},\n  {productId: 4, price: 17.99},\n  {productId: 5, price: 22.99},\n];\n\nconst totalSales = soldItems.reduce((accumulator, nextItem) =&gt; accumulator + nextItem.price, 0);\n</code></pre>\n<ul>\n<li><code>reduce</code> exists as a method on all arrays, it takes one uncalled function as the first argument</li>\n<li>This uncalled function is called for each item in the array, as reduce iterates over each item</li>\n<li>It also takes an optional second parameter, which will act as the first value<ul>\n<li>In the above example, <code>0</code> is the optional second parameter</li>\n<li>The first time reduce is called, <code>accumulator</code> is equal to <code>0</code></li>\n</ul>\n</li>\n<li>This function is provided the value currently being iterated over as the <strong>second</strong> parameter<ul>\n<li>In the above example, the first time it is called, <code>nextItem</code> is equal to <code>{productId: 1, price: 30.99}</code></li>\n</ul>\n</li>\n<li>The return of the function dictates what the value of the <code>accumulator</code> is the next time it is called<ul>\n<li>the first time it&#39;s called, we add <code>accumulator + nextItem.price</code> ie <code>0 + 30.99</code>, and return it</li>\n<li>the second time it&#39;s called, we add <code>accumulator + nextItem.price</code> ie <code>30.99 + 12.99</code>, and return it</li>\n<li>the third time it&#39;s called, we add <code>accumulator + nextItem.price</code> ie <code>43.98 + 61.99</code>, and return it</li>\n<li>etc</li>\n</ul>\n</li>\n<li>The final time the function is called and an item is returned, you resolve your reduce to whatever the last return is</li>\n</ul>\n<h2 id=\"useful-tips\">Useful Tips</h2>\n<ul>\n<li>Remember that you can return any sort of type in your reduce, and it will resolve to it</li>\n<li>A neat trick is turning an array into an object</li>\n</ul>\n<pre><code class=\"lang-js\">const soldItems = [\n  {productId: 1, price: 30.99},\n  {productId: 2, price: 12.99},\n  {productId: 3, price: 61.99},\n  {productId: 4, price: 17.99},\n  {productId: 5, price: 22.99},\n];\n\nconst groupedByPriceCategory = soldItems.reduce(\n  (acc, nextItem) =&gt; nextItem.price &lt; 20 ? \n  Object.assign({}, { underTwenty: acc.underTwenty.concat(nextItem) }) :\n  Object.assign({}, { overTwenty: acc.overTwenty.concat(nextItem) }), \n  {overTwenty: [], underTwenty: []});\n</code></pre>\n"}}