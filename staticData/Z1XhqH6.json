{"module":{"contents":{"data":{}},"title":"Observable Switchmap Vs Mergemap","path":"4-Observables/observable-switchmap-vs-mergemap","id":"observable-switchmap-vs-mergemap","body":"<h1 id=\"switchmap-vs-mergemap\">SwitchMap vs MergeMap</h1>\n<p>SwitchMap and MergeMap are smiliar operators, they&#39;re your go-to when you need to combine streams. Knowing the who, what, and why between these two operators will help you pick the right one for the job. Let&#39;s start with their similarites:</p>\n<h4 id=\"switchmap\">SwitchMap</h4>\n<p>SwitchMap is an operator that maps the values emitted from an observable to a different observable.</p>\n<h4 id=\"mergemap\">MergeMap</h4>\n<p>MergeMap is an operator that maps the values emitted from an observable to a different observable.</p>\n<hr>\n<p>Pretty <del>similar</del> identical so far, right? There <em>are</em> differences, but I&#39;ll save those for later.  Let&#39;s first pick apart this definition and then move to the differences. </p>\n<h4 id=\"switchmap-mergemap\">SwitchMap &amp; MergeMap</h4>\n<p>SwitchMap <em>and</em> MergeMap are operators that map the values emitted from an observable to a different observable.</p>\n<p>To start, let&#39;s break apart SwitchMap and MergeMap into the individual <strong>verbs</strong> that make them up: </p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th style=\"text-align:center\">What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td style=\"text-align:center\">?</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td style=\"text-align:center\">?</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td style=\"text-align:center\">?</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"map\">Map</h4>\n<p>When you see <strong>map</strong> you can read it as: </p>\n<blockquote>\n<p>Use the value of something to change it to something else.</p>\n</blockquote>\n<p>To expand on this, consider this tragic hypothetical. Imagine a world where there are no dogs. Only cats. At one point there <em>were</em> dogs, but somewhere in time CatConverter was created.  CatConverter is a machine that takes a group of dogs and converts them to cats! </p>\n<pre><code class=\"lang-javascript\">const dogs$ = Rx.Observable.from([\n  { name: &#39;sam&#39;, animal: &#39;dog&#39;, fur: &#39;brown&#39; },\n  { name: &#39;fluffy&#39;, animal: &#39;dog&#39;, fur: &#39;orange&#39; },\n  { name: &#39;jen&#39; , animal: &#39;dog&#39;, fur: &#39;black&#39; },\n]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(500))\n\nconst CatConverter = (dogs) =&gt; Rx.Observable.from(dogs)\n    .map((dog) =&gt; `Plain old cat`);\n\nCatConverter(dogs$)\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/2ORwP2Jd\">Run this code</a></p>\n<p>This CatConverter takes a list of dogs and converts them to cats.  But it&#39;s not making use of the &quot;<em><strong>value of something</strong></em>&quot; from our map definition above:</p>\n<blockquote>\n<p>Use the <em><strong>value of something</strong></em> to change it to something else.  </p>\n</blockquote>\n<p>Instead it&#39;s recieving a dog and returning a plain old cat. </p>\n<p>Let&#39;s update CatConverter so that instead of converting dogs to plain old cats, it creates cats with different colour fur. It will use the fur from the dog to create the cat.  (That sounds dark) </p>\n<pre><code class=\"lang-diff\">const dogs$ = Rx.Observable.from([\n  { name: &#39;sam&#39;, animal: &#39;dog&#39;, fur: &#39;brown&#39; },\n  { name: &#39;fluffy&#39;, animal: &#39;dog&#39;, fur: &#39;orange&#39; },\n  { name: &#39;jen&#39; , animal: &#39;dog&#39;, fur: &#39;black&#39; },\n]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(500))\n\nconst CatConverter = (dogs) =&gt; Rx.Observable.from(dogs)\n+    .map((dog) =&gt; `${dog.fur} cat`);\n\nCatConverter(dogs$)\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/L8k6Y2J7\">Run this code</a>.</p>\n<p>Notice the update to CatConverter? Now it uses the fur of the dog to determine the cat&#39;s colour.</p>\n<p>Now our definition for map makes sense:</p>\n<blockquote>\n<p>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>. </p>\n</blockquote>\n<p>A.K.A</p>\n<blockquote>\n<p>Use the <em><strong>colour of the dog&#39;s fur</strong></em> to change the dog to a <em><strong>cat with the dog&#39;s fur colour</strong></em>. </p>\n</blockquote>\n<p>It helps to keep this definition in mind because there are numourouse Rx operators that have the word <strong>map</strong> tacked on to the end. And it&#39;s always for the same reason: &quot;To use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.&quot;</p>\n<h5 id=\"operators-with-map\">Operators with map</h5>\n<ul>\n<li>map</li>\n<li>concatMap</li>\n<li>exhaustMap</li>\n<li>mergeMap</li>\n<li>switchMap</li>\n</ul>\n<p>Update the verbs with our map definition:</p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th>What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td>?</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td>?</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"merge\">Merge</h3>\n<p>Next verb in the list is merge.</p>\n<blockquote>\n<p>Merge takes two or more observable streams and combines them together.</p>\n</blockquote>\n<p>With that, come back to our world where there are cats <em>and</em> dogs.</p>\n<pre><code class=\"lang-javascript\">const dogs$ = Rx.Observable.from([\n  &#39;🐶 Rover&#39;,\n  &#39;🐶 Mr Muffin&#39;,\n  &#39;🐶 Huck&#39;,\n]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(1000))\n\nconst cats$ = Rx.Observable.from([\n  &#39;🐱 Precious&#39;,\n  &#39;🐱 Mittens&#39;,\n  &#39;🐱 Garfield&#39;,\n]).concatMap(cat =&gt; Rx.Observable.of(cat).delay(400))\n\nRx.Observable.merge(\n  dogs$,\n  cats$\n);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/RoQB01OM\">Run this code</a>.</p>\n<p>Looking at these two streams individually can be represented by these two marble diagrams:</p>\n<p><strong>dogs$:</strong><code>|-----d-----d-----d--------&gt;</code></p>\n<p><strong>cats$:</strong> <code>|-c--c--c------------------&gt;</code></p>\n<p>Each letter represents an emission <em>over time</em>.  </p>\n<p>Time? Yes, notice in the code snippit that the <code>dogs$</code> stream emits one dog every 1 second. And the <code>cats$</code> stream emits one cat every 0.4 of a second. Apparently cats are faster than dogs.</p>\n<p>Using <code>merge()</code> at the end of the snippit, we flatten these two streams into one stream. If you line everything up, that&#39;s visually easy to see:</p>\n<p><strong>dogs$:</strong><code>|-----d-----d-----d--------&gt;</code></p>\n<p><strong>cats$:</strong> <code>|-c--c--c------------------&gt;</code></p>\n<p><code>merge()</code></p>\n<p><strong>both$:</strong> <code>|-c--cd-c--d-----d---------&gt;</code></p>\n<p>See how the dogs on the <code>$dogs</code> stream line up with the dogs on the <code>both$</code> stream and the cats on the <code>cats$</code> stream line up with the cats on the <code>both$</code> stream? That&#39;s a merge.</p>\n<p>Update the verbs with our merge definition:</p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th>What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td>Merge takes two or more observable streams and <em><strong>combines</strong></em> them together.</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td>?</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"switch\">Switch</h3>\n<p>Last verb on the list is switch.</p>\n<blockquote>\n<p>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the orignal stream at each emission and changes to the new emitted stream.  At every subsequent emission from the root stream, it will stop listening to the previouse child stream. </p>\n</blockquote>\n<p>This is the tougher one of the bunch to understand based off the description, so let&#39;s jump to the cats and the dogs. </p>\n<p>Remember CatConverter? It&#39;s causing a pretty big imbalance in the universe.  Let&#39;s hack that thing. We&#39;re going to change it to an AnimalCloner! This way, any animal that wanders into the machine will get cloned every 100th of a second until the next animal wanders in. What could go wrong? Balance will be restored. </p>\n<pre><code class=\"lang-javascript\">const dogClones$ = Rx.Observable.interval(100).mapTo(&#39;🐶&#39;);\nconst catClones$ = Rx.Observable.interval(100).mapTo(&#39;🐱&#39;);\n\nconst catsAndDogs$ = Rx.Observable.from([\n  dogClones$,\n  dogClones$,\n  catClones$,\n  dogClones$,\n  catClones$,\n]).concatMap(animals$ =&gt; Rx.Observable.of(animals$).delay(1000));\n\nconst AnimalCloner = (animals$) =&gt; animals$;\n\nAnimalCloner(catsAndDogs$);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/6Jrz26JG\">Run this code</a></p>\n<p>First thing to note here is that it does NOT use the switch operator.  And has caused chaos:</p>\n<pre><code class=\"lang-javascript\">|------d$------d$------c$------d$------c$---------&gt;\n       |\n       |-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶&gt;\n                   |\n                   |-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-&gt;\n                         |\n                         |-🐱-🐱-🐱-🐱-🐱-🐱-🐱-🐱-&gt;\n                                 |\n                                 |-🐶-🐶-🐶-🐶-🐶-🐶&gt;\n                                        |\n                                        |-🐱-🐱-🐱-🐱&gt;\n</code></pre>\n<p>AnimalCloner is out of control. What we want is <em>one</em> stream of animals for each time an animal enters the cloner. Instead we end up with <em>multiple</em> streams. <code>Switch</code> to the rescue, but first we need to make sure we understand why there are multiple streams here.</p>\n<p><code>dogClones$</code>: This is a stream of dogs that emit every 100th of a second</p>\n<p><code>catClones$</code>: This is a stream of cats that emit every 100th of a second</p>\n<p><code>catsAndDogs$</code>: This is a stream that emits a mix of <strong>dogClones$</strong> and <strong>catClones$</strong> every second. The important take-away here is that this is a <strong>stream of streams</strong>.  That&#39;s why when we pass <code>catsAndDogs$</code> into <code>AnimalCloner()</code> we get that nasty barage of streams. What we want is one stream.  And this is exactly what&#39;s missing from the <strong>switch</strong> description:</p>\n<blockquote>\n<p>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the original stream at each emission and change to the new emitted stream.  At <em><strong>every subsequent emission from the root stream, it will stop listening to the previous child stream</strong></em>.  </p>\n</blockquote>\n<p>Let&#39;s add <code>switch()</code>.</p>\n<pre><code class=\"lang-javascript\">const dogClones$ = Rx.Observable.interval(100).mapTo(&#39;🐶&#39;);\nconst catClones$ = Rx.Observable.interval(100).mapTo(&#39;🐱&#39;);\n\nconst catsAndDogs$ = Rx.Observable.from([\n  dogClones$,\n  dogClones$,\n  catClones$,\n  dogClones$,\n  catClones$,\n]).concatMap(animals$ =&gt; Rx.Observable.of(animals$).delay(1000));\n\nconst AnimalCloner = (animals$) =&gt; animals$;\n\nAnimalCloner(catsAndDogs$).switch();\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/38MYm38v\">Run this code</a></p>\n<p>Fixed. Now it&#39;s just one nice stream that <em>switches</em> to the latest dog or cat stream over time. </p>\n<pre><code class=\"lang-javascript\">|------d$------d$------c$------d$------c$---------&gt;\n       |\n       |-🐶-🐶-🐶-🐶-🐱-🐱-🐱-🐶-🐶-🐶--🐱-🐱-🐱&gt;\n</code></pre>\n<p>Update the verbs with our switch definition:</p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th>What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td>Merge takes two or more observable streams and <em><strong>combines</strong></em> them together.</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the original stream at each emission and changes to the new emitted stream.  At every subsequent emission from the root stream, it will stop listening to the previous child stream.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"mergemap-switchmap\">MergeMap &amp; SwitchMap</h3>\n<p>Now that we have all the verbs defined, we can combine the definitions together to understand these two operators. </p>\n<h5 id=\"mergemap\">MergeMap</h5>\n<blockquote>\n<p>MergeMap changes (maps) the values emitted from one stream to a new stream.  It combines (merges) all the new streams into one stream. </p>\n</blockquote>\n<h5 id=\"switchmap\">SwitchMap</h5>\n<blockquote>\n<p>SwitchMap changes (maps) the values emitted from one stream to a new stream.  It stops listening to the previous stream and changes (switches) to the next stream. </p>\n</blockquote>\n<p>Let&#39;s see these in action, but this time I&#39;ll go with a more real-world example.</p>\n<p>Consider a chat app. The app has a list of users that you can click on to begin listening to their messages. At any point, you can click a different user to begin seeing their messages instead. In Observable land, this could look like:</p>\n<pre><code class=\"lang-javascript\">const kim = document.createElement(&#39;input&#39;);\nconst bob = document.createElement(&#39;input&#39;);\noutput.prepend(kim)\noutput.prepend(bob)\n\nkim.setAttribute(&#39;type&#39;, &#39;button&#39;);\nkim.setAttribute(&#39;value&#39;, &#39;kim&#39;);\n\nbob.setAttribute(&#39;type&#39;, &#39;button&#39;);\nbob.setAttribute(&#39;value&#39;, &#39;bob&#39;);\n\nconst chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n).mergeMap((clickEvent) =&gt; Rx.Observable\n   .interval(800)\n   .mapTo(`Hi from ${clickEvent.target.value}`)\n);\n\nchatStream$.map((message) =&gt; message);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/jOLw0Boy\">Run this code</a></p>\n<p>This example attempts to accomplish the chat requirements with <strong>mergeMap</strong>. Stepping through the code, we can understand what&#39;s going on.</p>\n<pre><code class=\"lang-javascript\">const kim = document.createElement(&#39;input&#39;);\nconst bob = document.createElement(&#39;input&#39;);\noutput.prepend(kim)\noutput.prepend(bob)\n\nkim.setAttribute(&#39;type&#39;, &#39;button&#39;);\nkim.setAttribute(&#39;value&#39;, &#39;kim&#39;);\n\nbob.setAttribute(&#39;type&#39;, &#39;button&#39;);\nbob.setAttribute(&#39;value&#39;, &#39;bob&#39;);\n</code></pre>\n<p>This creates the html buttons and gives them a value of either &#39;kim&#39; or &#39;bob&#39;.</p>\n<pre><code class=\"lang-javascript\">\nconst chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n)\n</code></pre>\n<p>This creates two streams and combines them. The streams are (1) clicks from &#39;bob&#39; and (2) clicks from &#39;kim&#39;.</p>\n<pre><code class=\"lang-javascript\">const chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n).mergeMap((clickEvent) =&gt; Rx.Observable\n   .interval(800)\n   .mapTo(`Hi from ${clickEvent.target.value}`)\n);\n</code></pre>\n<p>This <strong>mergeMap()&#39;s</strong> off the stream of clicks. Our definition of mergeMap tells us that it will <strong>change</strong> the value from the first stream of clicks into a <strong>new Observable</strong>.  The new Observable emits a message from the clicked user every 800th of a second. </p>\n<p>Unlike <strong>switchMap</strong>, as clicks are emitted from the first stream, the previous child message stream never actually stops.  They just keep collecting over time! That gets pretty noisy. </p>\n<p>Run the example and switch between bob and kim. You&#39;ll see each time you switch to a different user, the messages pile up. Clearly, we&#39;re not switching - we&#39;re merging!</p>\n<p>We need to switch. Let&#39;s update:</p>\n<pre><code class=\"lang-javascript\">const kim = document.createElement(&#39;input&#39;);\nconst bob = document.createElement(&#39;input&#39;);\noutput.prepend(kim)\noutput.prepend(bob)\n\nkim.setAttribute(&#39;type&#39;, &#39;button&#39;);\nkim.setAttribute(&#39;value&#39;, &#39;kim&#39;);\n\nbob.setAttribute(&#39;type&#39;, &#39;button&#39;);\nbob.setAttribute(&#39;value&#39;, &#39;bob&#39;);\n\nconst chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n).switchMap((clickEvent) =&gt; Rx.Observable\n   .interval(800)\n   .mapTo(`Hi from ${clickEvent.target.value}`)\n);\n\nchatStream$.map((message) =&gt; message);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/RoQBxAOM\">Run this code</a></p>\n<p>Switched! Run the example again and observe the new behaviour. It actually switches now. As you change from bob to kim, the stream stops listening to bob and <em><strong>switches</strong></em> to kim.</p>\n"}}