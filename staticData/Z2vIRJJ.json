{"module":{"contents":{"data":{}},"title":"Javascript Interpreter","path":"1-Javascript-General-Topics/javascript-interpreter","id":"javascript-interpreter","body":"<h2 id=\"javascript-interpreted\">JavaScript Interpreted</h2>\n<p>Being able to read and write JavaScript is a valuable skill for a developer, but writing the code is only part of understanding how JavaScript works. What <em>actually</em> happens after you hit save and run your code?</p>\n<p>Some programming languages (like Java and C#) are compiled, translated from <em>source code</em> written by developers into <em>machine code</em> the computer can read. But JavaScript isn&#39;t compiled - it is interpreted. So to understand how the code you write impacts the way your program works, it&#39;s important to know how your code is &#39;read&#39;, and what is doing the reading.</p>\n<h2 id=\"basics\">Basics</h2>\n<p>Your JavaScript code is a set of instructions for the interpreter. We call these instructions &#39;statements&#39;, which we separate with a semicolon and the interpreter reads from left to right.</p>\n<p>Unlike some other languages, JavaScript will still be interpreted with or without the semicolon. Despite this, Mozilla&#39;s developer docs recommend that semicolons are always used. You can read more about that here: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types</a></p>\n<p>To store values, JavaScript has seven data types, six of which are called primitives, and one called Object. Read on to learn how values are stored, and the differences between types!</p>\n<h2 id=\"variables\">Variables</h2>\n<p>In JavaScript, data is stored in an identifier called a <strong>variable</strong>. A variable represents the name you will use through out your application to store some data. A variable can be declared a number of ways:</p>\n<ul>\n<li><code>const</code>\nUsed for decaring a read-only, block-scoped value. Variables declared with <code>const</code> are constants, meaning they cannot be reassigned</li>\n<li><code>let</code>\nUsed for declaring a local, block-scoped variable. Can be reassigned.</li>\n<li><p><code>var</code>\nUsed for declaring a variable. Can be reassinged.</p>\n<p>In addition to being able to reassign their values, both <code>let</code> and <code>var</code> declarations can be used <em>before</em> a value is assigned to them, but <code>const</code> must be given a value upon declaration or an error is thrown.</p>\n<pre><code>var name; // works\nlet nextValue; // works\nconst studentName; // will throw error: `Uncaught SyntaxError: Missing initializer in const declaration`\n</code></pre><p>Variables can hold a variety of data, including primitives and Objects.</p>\n</li>\n</ul>\n<h2 id=\"what-are-primitives-\">What are primitives?</h2>\n<p>JavaScript&#39;s six primitive types are:</p>\n<ul>\n<li>Boolean - can have value <code>true</code> or <code>false</code></li>\n<li>Null - value is <code>null</code></li>\n<li>Undefined - no value been assigned, and so has the value of  <code>undefined</code></li>\n<li>Number - value is a number**</li>\n<li>String - accepts textual data enclosed in quotes.</li>\n<li>Symbol - this is the newest data type, introduced in ECMAScript 6. It can be used as the key of an object property</li>\n</ul>\n<p>** Number accepts more than just integers: it can also represent floating-point numbers, NaN and <code>+Infinity and -Inifinity</code>. You can read more about the Number type and other data structures here: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures</a></p>\n<h2 id=\"how-are-primitives-interpreted-\">How are primitives interpreted?</h2>\n<p>When the JavaScript interpreter encounters a variable, it first reads at the left-hand side of the expression (the part before the equals sign), then it assigns the right-hand side of the expression to the value on the left. So in the intance below, the variable <code>song</code> is assinged the value <code>Twinkle, Twinkle Little Star</code>:</p>\n<pre><code>  const song = &#39;Twinkle, Twinkle Little Star&#39;\n  console.log(song) // will return &#39;Twinkle, Twinkle Little Star&#39;\n</code></pre><p>JavaScript&#39;s primitive types are <strong>immutable</strong>, meaning they store their values directly on the variable, like in this example:</p>\n<p>``` let hero = &quot;Leia&quot;\n    let hero2 = hero;\n    hero = &quot;General Organa&quot;</p>\n<pre><code>console.log(hero2) // Leia\nconsole.log(hero) // General Organa\n</code></pre><pre><code>\nWhen we write the line `hero = &quot;General Organa&quot;`, we want to make the value of `hero` a new string. But when we `console.log(hero2)`, we&#39;re given the value `Leia`. Why? Because when we wrote `let hero2 = hero`, we stored the actual, current value of `hero` into the `hero2` variable. Later, when the value of `hero` is changed, our `hero2` variable doesn&#39;t change along with it.\n\n\n## Interpreting Objects\n\nA JavaScript object is a collection of key-value pairs known as &#39;properties&#39;. An object looks like this:\n</code></pre><p>let heroObject = {\n    name: &#39;Leia&#39;,\n    age: 60,\n    planet: &#39;Alderaan&#39;,\n    affliations: [&#39;Rebel Alliance&#39;,  &#39;Galactic Republic&#39;, &#39;Alderaan Royal Family&#39;, &#39;The Resistance&#39;]\n}</p>\n<pre><code>Unlike primitives, a JavaScript object is a complex data type and is **mutable**. This means if we make a change similiar to the primitive example above, we&#39;ll get different outputs in the console:\n</code></pre><p>​var heroObject2 = heroObject;\nheroObject.name = &quot;General Organa&quot;;\n​\nconsole.log(heroObject2.name); // General Organa\nconsole.log(heroObject.name); // General Organa</p>\n<pre><code>\nSo why didn&#39;t our first call return `Leia` like above? Because an object&#39;s values are stored as references rather than actual values. You can think of references like URLs: they&#39;re a *pointer* to some information, rather than the information itself. If the information stored on the pointer changes, every instance (whether URL or variable name) will now point to this new information.\n\n## Execution in the Browser\n\nJavaScript engines evaluate code as follows:\n\n1. Global function and variable declarations are defined and processed\n2. Separate execution contexts are created for each function\n3. Functions, variables and arguments inside each execution contexts are created (and new execution contexts are created for any function found inside another function)\n4. Assignment statements are executed\n\nIf the interpreter encounters any errors during this process, it stops. Any lines evaluated before the errors occured will remain evaluated, and any code following the errors will not be read.\nComments that are written into your code will also be ignored by the interpreter.\n\n(For an in-depth look at the above process, see: http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/)\n\n## Hoisting\n\nJavaScript interpreters move function and variable declarations to the top of their scope as the code is run - this is called &#39;hoisting&quot;. Because of hoisting, you are able to use a function or reference a variable *before* it is defined in code. For example:\n</code></pre><p>favouriteFood(&quot;ice cream&quot;);</p>\n<p>function favouriteFood(food) {\n  console.log(&quot;My favourite food is &quot; + food); // will return &#39;My favourite food is ice cream&quot;\n}</p>\n<pre><code>\nHoisting can also lead to some tricky errors to debug. A **declaration**, like the function declaration above, will be hoisted. An **expression** behaves differently:\n</code></pre><p>favouriteFood2(&quot;beans&quot;)</p>\n<p>var favouriteFood2 = function(food) {\n  console.log(&quot;My favourite food is &quot; + food);\n}</p>\n<p>// returns favouriteFood2 is not a function</p>\n<pre><code>\nSo what&#39;s happening here? The answer is that only *part* of the function expression is hoisted - the left side of the assignment is put into memory, but the interpreter recognizes the right side as an assignment statement and skips it (to come back later).\nThis results in a confusing error, since we *have* defined `favouriteFood2`...just not in the order we needed to.\n\nUsing the keyword `let` instead of `var` with this example returns a new error:\n</code></pre><p>favouriteFood3(&quot;pineapple&quot;)</p>\n<p>let favouriteFood3 = function(food) {\n  console.log(&quot;My favourite food is &quot; + food);\n}</p>\n<p>// returns favouriteFood3 is not defined</p>\n<p>```</p>\n<p>This error is more helpful, since it tells us there&#39;s a specific problem with our variable - it isn&#39;t defined by the time the interpreter is reading it.</p>\n<p>Understanding hoisting can be tricky, but it will help you avoid many errors in your code. An excellent explanation (with pictures!) can be found here: <a href=\"https://scotch.io/tutorials/understanding-hoisting-in-javascript\">https://scotch.io/tutorials/understanding-hoisting-in-javascript</a></p>\n"}}