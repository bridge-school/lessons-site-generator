{"module":{"contents":{"data":{}},"title":"Js Eventloop","path":"1-Javascript-General-Topics/js-eventloop","id":"js-eventloop","body":"<h1 id=\"the-javascript-event-loop\">The JavaScript Event Loop</h1>\n<h2 id=\"what-is-it-\">What is it?</h2>\n<p>Modern browsers have JavaScript engines that handle executing JavaScript using a model called the event loop. The event loop runs on a single thread - it only works on one thing at a time. It consist of three parts: stack, heap, and queue.</p>\n<p><a href=\"https://postimg.org/image/1759o89x23/\"><img src=\"https://s1.postimg.org/3k7w5fnq8v/async----event_loop.jpg\" alt=\"async----event_loop.jpg\"></a></p>\n<p>The basic idea is: during runtime, there are messages/tasks that are being created, lining up in a queue, and being processed one by one by the JavaScript engine. When a message is being processed, it uses the stack and heap to manage stuff the stuff it&#39;s doing - kind of like its own personal workspace. While a message is being processed, it may create other messages to be put into the queue. </p>\n<h3 id=\"heap\">Heap</h3>\n<p>The heap is just a mostly unstructured region where memory for objects is allocated. </p>\n<h3 id=\"stack\">Stack</h3>\n<p>The stack manages function calls at runtime. You can think of it as stacked <em>frames</em>, where each frame is a reference to a spot in some function scope. A frame is created when a function is called, and is removed when that function has completed. It might be helpful to think of a stack of blocks: the most immediate block you&#39;re dealing with is always the top block. That is, you add and remove blocks from the top (unless you&#39;re playing a game of Jenga).</p>\n<p>Below is a great example taken from <a href=\"http://exploringjs.com/es6/ch_async.html#sec_javascript-call-stack\">Exploring JS</a> to demonstrate the stack.</p>\n<p>Let&#39;s look at this code:</p>\n<pre><code>function h(z) {\n    // Print stack trace\n    console.log(new Error().stack); // (A)\n}\nfunction g(y) {\n    h(y + 1); // (B)\n}\nfunction f(x) {\n    g(x + 1); // (C)\n}\nf(3); // (D)\nreturn; // (E)\n</code></pre><p>Initially, when the program above is started, the call stack is empty. After the function call f(3) in line D, the stack has one entry:</p>\n<pre><code>|----------|\n| Location |\n| in global|\n| scope    |\n|----------|\n</code></pre><p>After the function call g(x + 1) in line C, the stack has two entries:</p>\n<pre><code>|----------|\n| Location |\n|  in f    |\n|          |\n|----------|\n| Location |\n| in global|\n| scope    |\n|----------|\n</code></pre><p>After the function call h(y + 1) in line B, the stack has three entries:</p>\n<pre><code>|----------|\n| Location |\n|  in g    |\n|          |\n|----------|\n| Location |\n|  in f    |\n|          |\n|----------|\n| Location |\n| in global|\n| scope    |\n|----------|\n</code></pre><p>The stack trace printed in line A shows you what the call stack looks like:</p>\n<pre><code>Error\n    at h (stack_trace.js:2:17)\n    at g (stack_trace.js:6:5)\n    at f (stack_trace.js:9:5)\n    at &lt;global&gt; (stack_trace.js:11:1)\n</code></pre><p>Next, each of the functions terminates and each time, the top entry is removed from the stack. After function f is done, we are back in global scope and the call stack is empty. In line E we return and the stack is empty, which means that the program terminates.</p>\n<h3 id=\"queue\">Queue</h3>\n<p>The queue is a place where messages line up to be processed during runtime. A message is like a task item (sidenote: they are often called tasks). Every message has an associated function. A message is processed when:</p>\n<ol>\n<li>It is at the front of the queue (first in line) </li>\n<li>The previous message is completely done being processed</li>\n</ol>\n<p>Only one message is processed at a time. The processing consists of calling the associated function, which creates the initial stack frame. That function will do its business and eventually complete aka be terminated and removed from the stack. The processing is completed when the stack is empty again.</p>\n<h2 id=\"when-are-messages-added-to-the-queue-\">When are messages added to the queue?</h2>\n<p>There are various things during runtime that are added to the queue as messages (for example, reaction to user input such as click). In the case of asynchronous tasks: if an async task is called and has an associated callback function, a message with the associated callback function will be put at the <strong>end</strong> of the queue <strong>after</strong> the task has completed and returned. That means the callback function will never be executed before the current message (the one that called the async task), is completed.</p>\n<h2 id=\"an-example\">An example</h2>\n<p>Let&#39;s look at an example. When you run this JS code, what do you expect to see in your console (in what order will the statements print)?</p>\n<pre><code class=\"lang-javascript\">console.log(&#39;script start&#39;);\n\nsetTimeout(function() {\n  console.log(&#39;hello!&#39;);\n}, 0);\n\nconsole.log(&#39;script end&#39;);\n</code></pre>\n<p><a href=\"https://repl.it/OBrd/0\">Try it out yourself</a></p>\n<p>It turns out they print in this order:</p>\n<pre><code>script start\nscript end\nhello!\n</code></pre><p>Why doesn&#39;t <code>hello!</code> print before <code>script end</code> if the <code>setTimeout</code> comes before the last <code>console.log</code> and has a delay of 0 milliseconds?</p>\n<p><code>setTimeout</code> is an asynchronous function. The delay you give it does not set the amount of time before the callback function executes, but rather, the minimum amount of time before the callback function can be added to the queue. Remember that only one message can be processed at a time and it must complete before the next message is processed.</p>\n<p>So in this example, this program starts and is on the call stack. <code>console.log</code> is executed synchronously so it logs &#39;script start&#39;. Then comes the <code>setTimeout</code> which puts the logging callback function into the queue. The current program continues, logging &#39;script end&#39;. Then it is completed and popped off the stack - the message is terminated. Only then can the next message in the queue (the callback that logs &#39;hello!&#39;) be processed. </p>\n"}}