{"module":{"contents":{"data":{}},"title":"Immutability","path":"1-Javascript-General-Topics/immutability","id":"immutability","body":"<h2 id=\"object-immutability\">Object Immutability</h2>\n<ul>\n<li>First, lets remember that we can have multiple variables all <code>pointing</code> to the same object</li>\n<li>When this happens changing something in the copy seemingly changes something in the original too</li>\n</ul>\n<pre><code class=\"lang-js\">var originalMsMarvel = {\n    firstName: &#39;Carol&#39;,\n    lastName: &#39;Danvers&#39;,\n    superPower: &#39;Flying and other stuff&#39;\n}\n\n// Here they are both the same\nvar newMsMarvel = originalMsMarvel;\n\nnewMsMarvel.firstName = &#39;Kamala&#39;;\nnewMsMarvel.lastName = &#39;Khan&#39;;\n\nconsole.log(&#39;the new ms Marvel&#39;, newMsMarvel);\nconsole.log(&#39;the original ms Marvel&#39;, originalMsMarvel);\n</code></pre>\n<ul>\n<li>In the above example, the original object has been mutated!</li>\n<li>This is because Javascript likes to have objects sharing references</li>\n<li>There are ways around this</li>\n</ul>\n<h2 id=\"sometimes-you-need-to-turn-an-array-of-numbers-into-just-one-big-number\">Sometimes you need to turn an array of numbers into just one big number</h2>\n<pre><code class=\"lang-js\">var originalMsMarvel = {\n    firstName: &#39;Carol&#39;,\n    lastName: &#39;Danvers&#39;,\n    superPower: &#39;Strong and stuff&#39;\n}\n\n// Here they are both the same, however we use Object assign to create a new reference\nvar newMsMarvel = Object.assign({}, originalMsMarvel);\n\n//This will not work!\n//var newMsMarvel = Object.assign(originalMsMarvel);\n\nnewMsMarvel.firstName = &#39;Kamala&#39;;\nnewMsMarvel.lastName = &#39;Khan&#39;;\n\nconsole.log(&#39;the new ms Marvel&#39;, newMsMarvel);\nconsole.log(&#39;the original ms Marvel&#39;, originalMsMarvel);\n</code></pre>\n<ul>\n<li>Here we can use Object.assign to force a new reference in memory, it shallow merges all arguments (which are objects)</li>\n<li>When using object assign, the FIRST object is the final reference in memory, use a new object literal <code>{}</code> for a new reference</li>\n</ul>\n<h2 id=\"primitive-immutability\">Primitive Immutability</h2>\n<ul>\n<li>All Primitives are immutable! They cannot be changed like an object can be</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">Primitives</a><ul>\n<li>string, number, boolean, null, undefined, symbol (new in es2015)</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"lang-js\">var originalMsMarvel = &#39;Carol Danvers is strong and stuff!&#39;;\nvar newMsMarvel = originalMsMarvel;\n\nnewMsMarvel = newMsMarvel.replace(&#39;Carol Danvers&#39;, &#39;Kamala Khan&#39;);\n\nconsole.log(originalMsMarvel, newMsMarvel);\n</code></pre>\n<ul>\n<li>Above, you can see the original string has not een changed, even when we update <code>newMsMarvel</code></li>\n</ul>\n<h3 id=\"const\">Const</h3>\n<ul>\n<li>Introduced in es2015 to help keep code immutable</li>\n</ul>\n<pre><code class=\"lang-js\">var animal = &#39;horse&#39;;\nanimal = &#39;unicorn&#39;;\n\nconsole.log(&#39;var change&#39;, animal);\n\nlet animal2 = &#39;horse&#39;;\nanimal2 = &#39;unicorn&#39;;\n\nconsole.log(&#39;let change&#39;, animal2);\n\nconst animal3 = &#39;horse&#39;;\nanimal3 = &#39;unicorn&#39;; // Will give you an error\n</code></pre>\n<ul>\n<li>const prevents you from overriding variables, but does not protect against object mutation</li>\n</ul>\n<h2 id=\"array-immutability\">Array immutability</h2>\n<ul>\n<li>Keeping Arrays immutable can be done with the right methods!</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">List of Mutating vs non mutating methods available in Array instance/methods</a></li>\n</ul>\n"}}