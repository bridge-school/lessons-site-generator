{"module":{"contents":{"data":{"layout":"page","permalink":"/redux-action-reducer/"}},"title":"Redux Action Reducer","path":"6-Redux/redux-action-reducer","id":"redux-action-reducer","body":"<hr>\n<h2 id=\"adding-search\">Adding Search</h2>\n<ul>\n<li>Filter robots by matching their names against a search string</li>\n<li>Need to separate:<ul>\n<li>The entire list of robots</li>\n<li>The currently-displayed list of robots</li>\n</ul>\n</li>\n<li>Latter changes each time a search is run<ul>\n<li>Which means that search updates state</li>\n</ul>\n</li>\n<li>We need:<ul>\n<li>An action object</li>\n<li>With an action type</li>\n<li>And a reducer to handle it</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"giving-the-action-a-name\">Giving the Action a Name</h2>\n<ul>\n<li>Define a constant to identify this action<ul>\n<li>Could use a raw string in this case</li>\n<li>But we know we&#39;re going to want symbolic constants in namespaces eventually</li>\n</ul>\n</li>\n<li>Put it in the file <code>constants.js</code></li>\n</ul>\n<pre><code>export const SET_SEARCH_TERM = &quot;SET_SEARCH_TERM&quot;;\n</code></pre><hr>\n<h2 id=\"create-an-action-object\">Create an Action Object</h2>\n<ul>\n<li>Define a function in <code>actions.js</code> to create an object representing an action</li>\n<li>Again, more elaborate than we need for this small example</li>\n<li>But we will eventually want to insulate ourselves from details</li>\n<li>Put this in <code>actions.js</code><ul>\n<li>Larger applications will have one file of actions per module</li>\n</ul>\n</li>\n</ul>\n<pre><code>import CHANGE_SEARCHTERM from &#39;constants&#39;\n\nexport const setSearchTerm = (text) =&gt;  { type: CHANGE_SEARCHTERM, payload: text }\n</code></pre><hr>\n<h2 id=\"handle-the-action\">Handle the Action</h2>\n<ul>\n<li>Create the complement to our action generator in <code>reducers.js</code></li>\n<li>A constant defining the initial state...</li>\n<li>...that is the default value of reducer function&#39;s <code>state</code> argument...</li>\n<li>...and an <code>action</code> that tells the function how to update state</li>\n</ul>\n<pre><code>import { CHANGE_SEARCHTERM } from &#39;actions&#39;\n\nconst initialState = {\n  searchTerm: &#39;&#39;\n}\n\nconst robotsSearch = (state=initialState, action={}) =&gt; {\n  switch (action.type) {\n    case CHANGE_SEARCHTERM:\n      return Object.assign({}, state, {searchTerm: action.payload})\n    default:\n      return state\n  }\n}\n\nexport default robotsSearch;\n</code></pre><ul>\n<li>If our reducer doesn&#39;t recognize the action, it does nothing<ul>\n<li>Which makes it safe for us to chain reducers together</li>\n<li>Note that <code>action</code> has a default value of <code>{}</code><ul>\n<li>So <code>action.type</code> will be <code>undefined</code> if we forget to pass an action</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Use <code>Object.assign</code> to merge current state with action&#39;s payload<ul>\n<li>Does the right thing the first time because <code>initialState</code> is the default value of <code>state</code></li>\n</ul>\n</li>\n<li>Reducer functions <em>always</em> return a new state object<ul>\n<li>May recycle parts of the old state (we&#39;ll see that later)</li>\n<li>But <em>never</em> mutate state in place</li>\n</ul>\n</li>\n</ul>\n"}}