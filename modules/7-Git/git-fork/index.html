<!DOCTYPE html><html lang="en-US" data-reactroot=""><head><title data-react-helmet="true"></title><link rel="stylesheet" href="https://g2graman.github.io/lessons-site-generator/styles.e0969f35.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/><link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css"/><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:500"/></head><body><div class="slug-home"><div id="root"><div data-reactroot=""><header class=" mdc-toolbar"><div class=" mdc-toolbar__row"><section class="brand  mdc-toolbar__section mdc-toolbar__section--align-start"><svg width="48" height="48" viewBox="0 0 1205 863" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>white bridge logo</title><desc>white bridge logo</desc><use xlink:href="#a" transform="translate(0 485.01)" fill="#FAFAFA"></use><use xlink:href="#b" transform="translate(246.1 572.65)" fill="#FAFAFA"></use><use xlink:href="#c" transform="translate(412.5 486)" fill="#FAFAFA"></use><use xlink:href="#d" transform="translate(522.1 486)" fill="#FAFAFA"></use><use xlink:href="#e" transform="translate(768.2 573.64)" fill="#FAFAFA"></use><use xlink:href="#f" transform="translate(1013.3 573.64)" fill="#FAFAFA"></use><g><use xlink:href="#g" transform="translate(198.3 1)" fill="#FAFAFA"></use><use xlink:href="#h" transform="translate(859.9)" fill="#FAFAFA"></use><use xlink:href="#i" transform="translate(382.6)" fill="#FAFAFA"></use><use xlink:href="#j" transform="translate(381.6 106.56)" fill="#FAFAFA"></use></g><defs><path id="a" d="M57.792 297.776H0V0h57.792v110.546c8.967-10.955 29.892-21.91 50.816-21.91 59.785 0 92.666 48.799 92.666 107.557 0 58.759-33.878 106.562-92.666 106.562-21.92 0-42.845-10.955-50.816-21.91v16.931zm0-68.718c6.974 13.943 21.92 23.902 37.863 23.902 30.889 0 48.824-24.898 48.824-57.763 0-32.864-17.935-57.762-48.824-57.762-15.942 0-31.885 9.959-37.863 23.902v67.721z"></path><path id="b" d="M125.547 61.746c-7.971-4.98-17.935-6.971-28.895-6.971-18.932 0-34.875 9.959-39.857 28.881v126.48H0V4.98h56.795v19.918C65.763 9.959 82.702 0 102.63 0c9.964 0 17.935 1.992 21.921 2.988l.996 58.758z"></path><path id="c" d="M33.878 65.73C15.943 65.73 0 52.783 0 32.865 0 14.939 14.946 0 33.878 0c17.935 0 33.878 12.947 33.878 32.865-.997 19.918-16.94 32.865-33.878 32.865zm27.9 231.05H4.981V92.62h56.795v204.16z"></path><path id="d" d="M143.483 279.849c-8.968 10.955-29.893 21.91-50.817 21.91C32.88 301.759 0 253.956 0 195.197 0 136.439 33.878 87.64 92.666 87.64c21.921 0 42.845 10.955 50.817 21.91V0h57.791v297.776h-57.791v-17.927zm0-118.512c-6.975-12.947-21.921-23.902-37.864-23.902-30.888 0-48.824 24.897-48.824 57.762s17.936 57.763 48.824 57.763c16.939 0 31.885-9.959 37.864-23.902v-67.721z"></path><path id="e" d="M142.486 184.242c-8.967 10.955-27.899 20.914-49.82 20.914C32.882 205.156 0 157.353 0 102.578 0 47.803 33.878 0 92.666 0c22.917 0 40.853 9.959 49.82 19.918V3.984h56.795v182.25c0 69.714-42.845 102.578-100.637 102.578-52.81 0-89.676-26.889-95.655-72.701h54.803c4.982 18.923 17.935 28.882 39.856 28.882 28.896 0 43.842-16.931 43.842-49.796l.996-10.955zm0-115.524c-6.975-11.951-21.921-20.915-37.863-20.915-30.889 0-47.828 22.906-47.828 54.775s17.936 54.775 47.828 54.775c16.939 0 31.885-9.959 37.863-21.91V68.717z"></path><path id="f" d="M190.314 142.414c-7.972 42.824-39.857 71.706-90.673 71.706C39.856 214.12 0 171.296 0 107.558 0 44.816 40.853 0 98.644 0c60.781 0 92.666 40.832 92.666 101.582v16.931H54.802c1.993 30.873 18.932 48.799 43.842 48.799 18.932 0 33.878-7.967 37.864-25.893l53.806.995zM56.795 84.652h78.716c0-21.91-12.953-37.844-36.867-37.844-21.92 0-37.863 12.946-41.849 37.844z"></path><path id="g" d="M85.69 302.755c0 8.963 4.983 13.943 13.95 13.943h46.832v42.824H99.641c-36.867 0-62.774-23.902-62.774-60.75V214.12c0-8.964-4.982-13.943-13.95-13.943H0v-43.82h23.914c8.967 0 13.95-4.979 13.95-13.943V60.75C37.863 22.906 63.77 0 100.636 0h45.835v42.824H99.641c-8.968 0-13.95 4.98-13.95 13.943v80.668c0 20.914-9.964 31.869-22.917 39.836 12.953 7.967 22.917 18.922 22.917 39.836v85.648z"></path><path id="h" d="M60.78 217.107c0-20.914 9.965-31.869 22.918-39.836-12.953-7.967-22.917-18.922-22.917-39.836V55.771c0-8.963-4.982-13.943-13.95-13.943H0V0h45.835c36.867 0 62.773 23.902 62.773 60.75v79.673c0 8.963 4.982 13.942 13.95 13.942h23.914v44.816h-23.914c-8.968 0-13.95 4.98-13.95 13.943v84.652c0 37.844-25.906 60.75-62.773 60.75H0v-42.824h46.831c8.968 0 13.95-4.98 13.95-13.943v-84.652z"></path><path id="i" d="M220.206 0H0v41.828H439.415V0H220.206z"></path><path id="j" d="M374.649 210.136v-59.754C374.649 65.73 307.89 0 222.199 0h-3.986c-85.691 0-152.45 65.73-152.45 150.382v59.754H0v42.824h107.612V151.378c0-60.75 48.824-108.554 110.601-108.554h3.986c61.777 0 110.601 47.803 110.601 108.554V252.96h107.612v-42.824h-65.763z"></path></defs></svg></section><section class="navigation  mdc-toolbar__section"><nav><a href="https://g2graman.github.io/lessons-site-generator/">Modules</a><a href="https://g2graman.github.io/lessons-site-generator/about">About</a></nav></section></div></header><div class="content"><div><a href="https://g2graman.github.io/lessons-site-generator/"><button class=" mdc-button mdc-button--stroked">Back to Modules</button></a><br/><h3>Git Fork</h3><p><h1 id="git-forking-a-repository">Git: Forking a repository</h1>
<blockquote>
<p><em>Ah, the life! Branching, committing, pushing, pulling, merging... modifying code to my hearts&#39; content... breathing life into features like some sort of magician or squashing bugs like an exterminator. Bliss. Until...</em></p>
</blockquote>
<pre><code class="lang-bash">! [remote rejected] master -&gt; master (protected branch hook declined)
error: failed to push some refs to &#39;git@github.com:some-account/some-repo.git&#39;
</code></pre>
<p>☹️</p>
<p>When working with code, there are times when you will want to modify code that resides in a repository that is not under your control, or you may just not want to work with that repo or its maintainers directly. You might want to introduce features that are outside the scope of the project. You may want to build something completely unrelated and just use the repository as a starting point. Maybe a useful library needs a bug fix, but the maintainer has abandoned the repository. </p>
<p>For all these times and <a href="#why-would-we-want-a-fork">more</a>, there&#39;s <strong>Forking</strong>!</p>
<p>Read on, or <a href="#the-short-version">skip to the short version</a>!</p>
<h2 id="what-is-a-fork-">What is a Fork?</h2>
<p>Forking is creating a new copy of the entire repository. This might sound like <code>git clone</code>, and behind the scenes it is. The difference is in where the new copy resides. A &quot;clone&quot; typically refers to a <em>local</em> copy of some repository. A <em>fork</em>, in contrast, is a second <em>remote</em> repository distinct from the original.</p>
<p>Historically, a <em>fork</em> was created when a developer or team wanted to take a project in a new direction, or carry on the original mission while the core project undergoes some major shift. Some examples of this are <a href="http://anandmanisankar.com/posts/nodejs-iojs-why-the-fork/#why-the-fork">NodeJS being forked as IO.js</a>, or when Oracle&#39;s take over of <code>OpenOffice</code> <a href="https://en.wikipedia.org/wiki/LibreOffice#ooo-build,_Go-oo_and_Oracle">led to the LibreOffice fork</a>, and ultimately OpenOffice&#39;s demise. These classic situations can be referred to as <strong>hard forks</strong>, where the forked code is not meant to be integrated back into the original (upstream) codebase. What we deal with most often are so called <strong>soft forks</strong>, where we <em>do</em> intend for our changes to be integrated back into the original repository, and the fork is a convenient system for creating an isolated workspace. From here on when we say &quot;fork&quot; we will be talking about soft forks, unless explicitly stated otherwise.</p>
<h2 id="how-do-i-make-a-fork-">How do I make a fork?</h2>
<p>You can do this manually by cloning a repository locally and then pushing to a new remote repository in a place of your choosing (GitHub, GitLab, BitBucket, etc). You would do so like this:</p>
<pre><code class="lang-bash">$&gt; git clone git@github.com:some-account/some-repo.git
$&gt; git remote add myfork git@github.com:fork-account/fork-repo.git
$&gt; git push myfork master
</code></pre>
<p>Note: more about <a href="#dealing-with-multiple-remotes">managing <code>remote</code>s</a> below.</p>
<p>GitHub and most other git-based version control services have forking built in as a feature that will automatically create a new repository under your account and copy the source repository into your new repository.</p>
<p>On GitHub, for example, this can be accomplished simply by clicking the &quot;Fork&quot; button in the top right corner, just under your account avatar. See here:
<img src="../images/github-fork.png" alt="Forking on GitHub"></p>
<h2 id="why-would-we-want-a-fork-">Why would we want a fork?</h2>
<h3 id="why-not-just-branch-">Why not just branch?</h3>
<p>So far we have mostly discussed the reasons one may want or need to create a <em>hard</em> fork of some project, where we intend on making permanently incompatible changes, but we have not justified our more typical (soft) fork situation. As you recall, this is for work which we want to eventually merge back into the main repository. Some reasons for doing this are:</p>
<ul>
<li><strong>User workspaces:</strong> some projects involve a large number of developers (imagine a popular open source or large enterprise project) and if every developer pushes multiple branches of their work to the same repository, that repository can become very cluttered. When you synchronize your local instance in those cases, you will have many more branches listed than you need or care about as you&#39;ll see branches for everybody&#39;s work.</li>
<li><strong>Clean main repository:</strong> as in the above case, but even for smaller teams, often the main repository is kept as the source-of-truth for the <code>master</code> (or <code>develop</code>) branch, and is otherwise reserved for CI and CD tasks, such as preserving production release versions. Branches for work-in-progress are relegated to user forks only in order to keep the central repo tidy.</li>
<li><strong>Experimental changes:</strong> Sometimes you need to make large architectural changes or adjust CI/CD configuration, and it isn&#39;t acceptable to block work on the main repo. Configuring another pipeline against a fork is one option to get around this.</li>
</ul>
<h2 id="dealing-with-multiple-remote-s">Dealing with multiple <code>remote</code>s</h2>
<p>When you set up your local repository with multiple <code>remote</code> repositories (usually the main repository and your own fork), there are slight changes to some of the <code>git</code> commands you are accustomed to using. Specifically, for any commands that deal with remote repositories (<code>push</code>, <code>pull</code>, <code>fetch</code> etc), you now need to specify the repository with which you want to interact.</p>
<p>For the following examples, imagine you cloned from your fork, so the repo copy under your account is the remote named <code>origin</code>, and we&#39;ve added a second remote called <code>upstream</code> for the main reposiory.</p>
<h3 id="-pull-"><code>pull</code></h3>
<p>When pulling the latest changes for a tracked remote branch, you now specify the full source, including the remote name:</p>
<pre><code class="lang-shell">$&gt; git pull upstream master
</code></pre>
<h3 id="-push-"><code>push</code></h3>
<p>Now when you push a branch, you will need to specify the target remote by name:</p>
<pre><code class="lang-shell">$&gt; git push origin my-cool-feature
</code></pre>
<p>A common workflow is to push your work-in-progress feature branches to your fork, and then issue a Pull Request from there back to the main repository.</p>
<h3 id="-fetch-"><code>fetch</code></h3>
<p>If you want to retrieve all of the latest changes from some remote (usually <code>upstream</code>), you can do so via <code>fetch</code>:</p>
<pre><code class="lang-shell">$&gt; git fetch upstream
</code></pre>
<h3 id="-rebase-"><code>rebase</code></h3>
<p><em>TBD</em> - should we cover this?</p>
<h2 id="the-short-version">The Short Version</h2>
<p>If your team uses forks as part of their flow, after get acess to the main repository you should do the following:
1) Create a personal fork of the repository on whichever platform the team uses.
1) Clone <em>your fork</em> locally: <code>git clone git@github.com:your-account/shared-repo.git</code>
1) Add the main repository as another remote: <code>git remote add upstream git@github.com:repo-owner-account/shared-repo.git</code>
1) Checkout the <code>master</code> branch
1) <a href="./git-branch-stage-commit.md">Create a branch</a> for your feature: <code>git checkout -b feat/my-cool-feature</code>
1) Develop! Commit! Get it to the point where you&#39;re ready to propose merging the code.
1) Get the latest code from the upstream repo (other code may have been merged): <code>git fetch upstream</code>
1) <a href="git-rebase.md">Rebase</a> your branch against the latest version of <code>master</code> from <code>upstream</code>: <code>git rebase upstream/master</code>
  1) Follow the steps, being very careful to resolve any <em>merge conflicts</em> if necessary.
1) Push your rebased branch to your <code>origin</code>: <code>git push origin feat/my-cool-feature</code></p>
<h2 id="gotchas">Gotchas</h2>
<p>Sometimes you will need to rebase your branch after you push it, because somebody else had made a change to the code and you need to update your branch before your PR can be merged. Just <code>fetch</code> the latest changes, and <code>rebase</code> as above. When this happens, you may encounter an error when you go to push your code to your <code>origin</code>:</p>
<pre><code>ADD ERROR HERE
</code></pre><p>This is because rebasing <em>changes your commits</em>. Your updated commits (and any new ones) are no longer compatible with the commits you push before. You have to overwrite them:
<code>git push origin feat/my-cool-feature -f</code>
The <code>-f</code> t the end of the commend tells git to do a &quot;force&quot; push, which replaces all the commits that are on the remote branch with your new rebased version.</p>
<h2 id="check-your-understanding">Check your understanding</h2>
<ul>
<li>How is a fork of a repository different than a clone?</li>
<li>What are some reasons for forking?</li>
<li>What do we mean by hard and soft forks?</li>
</ul>
<h2 id="more-resources">More resources</h2>
<p>Some further reading</p>
<ul>
<li><a href="https://help.github.com/articles/fork-a-repo/">GitHub help article</a></li>
<li><a href="TODO">Atlassian&#39;s explanation</a></li>
<li><a href="https://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/">Another perspective on forks</a></li>
</ul>
</p></div></div></div></div></div><script type="text/javascript">
                window.__routeData = {"path":"/modules/7-Git/git-fork","propsMap":{"__local":"6QAGO"},"initialProps":{"module":{"contents":{"data":{}},"title":"Git Fork","path":"7-Git/git-fork","id":"git-fork","body":"<h1 id=\"git-forking-a-repository\">Git: Forking a repository</h1>\n<blockquote>\n<p><em>Ah, the life! Branching, committing, pushing, pulling, merging... modifying code to my hearts&#39; content... breathing life into features like some sort of magician or squashing bugs like an exterminator. Bliss. Until...</em></p>\n</blockquote>\n<pre><code class=\"lang-bash\">! [remote rejected] master -&gt; master (protected branch hook declined)\nerror: failed to push some refs to &#39;git@github.com:some-account/some-repo.git&#39;\n</code></pre>\n<p>☹️</p>\n<p>When working with code, there are times when you will want to modify code that resides in a repository that is not under your control, or you may just not want to work with that repo or its maintainers directly. You might want to introduce features that are outside the scope of the project. You may want to build something completely unrelated and just use the repository as a starting point. Maybe a useful library needs a bug fix, but the maintainer has abandoned the repository. </p>\n<p>For all these times and <a href=\"#why-would-we-want-a-fork\">more</a>, there&#39;s <strong>Forking</strong>!</p>\n<p>Read on, or <a href=\"#the-short-version\">skip to the short version</a>!</p>\n<h2 id=\"what-is-a-fork-\">What is a Fork?</h2>\n<p>Forking is creating a new copy of the entire repository. This might sound like <code>git clone</code>, and behind the scenes it is. The difference is in where the new copy resides. A &quot;clone&quot; typically refers to a <em>local</em> copy of some repository. A <em>fork</em>, in contrast, is a second <em>remote</em> repository distinct from the original.</p>\n<p>Historically, a <em>fork</em> was created when a developer or team wanted to take a project in a new direction, or carry on the original mission while the core project undergoes some major shift. Some examples of this are <a href=\"http://anandmanisankar.com/posts/nodejs-iojs-why-the-fork/#why-the-fork\">NodeJS being forked as IO.js</a>, or when Oracle&#39;s take over of <code>OpenOffice</code> <a href=\"https://en.wikipedia.org/wiki/LibreOffice#ooo-build,_Go-oo_and_Oracle\">led to the LibreOffice fork</a>, and ultimately OpenOffice&#39;s demise. These classic situations can be referred to as <strong>hard forks</strong>, where the forked code is not meant to be integrated back into the original (upstream) codebase. What we deal with most often are so called <strong>soft forks</strong>, where we <em>do</em> intend for our changes to be integrated back into the original repository, and the fork is a convenient system for creating an isolated workspace. From here on when we say &quot;fork&quot; we will be talking about soft forks, unless explicitly stated otherwise.</p>\n<h2 id=\"how-do-i-make-a-fork-\">How do I make a fork?</h2>\n<p>You can do this manually by cloning a repository locally and then pushing to a new remote repository in a place of your choosing (GitHub, GitLab, BitBucket, etc). You would do so like this:</p>\n<pre><code class=\"lang-bash\">$&gt; git clone git@github.com:some-account/some-repo.git\n$&gt; git remote add myfork git@github.com:fork-account/fork-repo.git\n$&gt; git push myfork master\n</code></pre>\n<p>Note: more about <a href=\"#dealing-with-multiple-remotes\">managing <code>remote</code>s</a> below.</p>\n<p>GitHub and most other git-based version control services have forking built in as a feature that will automatically create a new repository under your account and copy the source repository into your new repository.</p>\n<p>On GitHub, for example, this can be accomplished simply by clicking the &quot;Fork&quot; button in the top right corner, just under your account avatar. See here:\n<img src=\"../images/github-fork.png\" alt=\"Forking on GitHub\"></p>\n<h2 id=\"why-would-we-want-a-fork-\">Why would we want a fork?</h2>\n<h3 id=\"why-not-just-branch-\">Why not just branch?</h3>\n<p>So far we have mostly discussed the reasons one may want or need to create a <em>hard</em> fork of some project, where we intend on making permanently incompatible changes, but we have not justified our more typical (soft) fork situation. As you recall, this is for work which we want to eventually merge back into the main repository. Some reasons for doing this are:</p>\n<ul>\n<li><strong>User workspaces:</strong> some projects involve a large number of developers (imagine a popular open source or large enterprise project) and if every developer pushes multiple branches of their work to the same repository, that repository can become very cluttered. When you synchronize your local instance in those cases, you will have many more branches listed than you need or care about as you&#39;ll see branches for everybody&#39;s work.</li>\n<li><strong>Clean main repository:</strong> as in the above case, but even for smaller teams, often the main repository is kept as the source-of-truth for the <code>master</code> (or <code>develop</code>) branch, and is otherwise reserved for CI and CD tasks, such as preserving production release versions. Branches for work-in-progress are relegated to user forks only in order to keep the central repo tidy.</li>\n<li><strong>Experimental changes:</strong> Sometimes you need to make large architectural changes or adjust CI/CD configuration, and it isn&#39;t acceptable to block work on the main repo. Configuring another pipeline against a fork is one option to get around this.</li>\n</ul>\n<h2 id=\"dealing-with-multiple-remote-s\">Dealing with multiple <code>remote</code>s</h2>\n<p>When you set up your local repository with multiple <code>remote</code> repositories (usually the main repository and your own fork), there are slight changes to some of the <code>git</code> commands you are accustomed to using. Specifically, for any commands that deal with remote repositories (<code>push</code>, <code>pull</code>, <code>fetch</code> etc), you now need to specify the repository with which you want to interact.</p>\n<p>For the following examples, imagine you cloned from your fork, so the repo copy under your account is the remote named <code>origin</code>, and we&#39;ve added a second remote called <code>upstream</code> for the main reposiory.</p>\n<h3 id=\"-pull-\"><code>pull</code></h3>\n<p>When pulling the latest changes for a tracked remote branch, you now specify the full source, including the remote name:</p>\n<pre><code class=\"lang-shell\">$&gt; git pull upstream master\n</code></pre>\n<h3 id=\"-push-\"><code>push</code></h3>\n<p>Now when you push a branch, you will need to specify the target remote by name:</p>\n<pre><code class=\"lang-shell\">$&gt; git push origin my-cool-feature\n</code></pre>\n<p>A common workflow is to push your work-in-progress feature branches to your fork, and then issue a Pull Request from there back to the main repository.</p>\n<h3 id=\"-fetch-\"><code>fetch</code></h3>\n<p>If you want to retrieve all of the latest changes from some remote (usually <code>upstream</code>), you can do so via <code>fetch</code>:</p>\n<pre><code class=\"lang-shell\">$&gt; git fetch upstream\n</code></pre>\n<h3 id=\"-rebase-\"><code>rebase</code></h3>\n<p><em>TBD</em> - should we cover this?</p>\n<h2 id=\"the-short-version\">The Short Version</h2>\n<p>If your team uses forks as part of their flow, after get acess to the main repository you should do the following:\n1) Create a personal fork of the repository on whichever platform the team uses.\n1) Clone <em>your fork</em> locally: <code>git clone git@github.com:your-account/shared-repo.git</code>\n1) Add the main repository as another remote: <code>git remote add upstream git@github.com:repo-owner-account/shared-repo.git</code>\n1) Checkout the <code>master</code> branch\n1) <a href=\"./git-branch-stage-commit.md\">Create a branch</a> for your feature: <code>git checkout -b feat/my-cool-feature</code>\n1) Develop! Commit! Get it to the point where you&#39;re ready to propose merging the code.\n1) Get the latest code from the upstream repo (other code may have been merged): <code>git fetch upstream</code>\n1) <a href=\"git-rebase.md\">Rebase</a> your branch against the latest version of <code>master</code> from <code>upstream</code>: <code>git rebase upstream/master</code>\n  1) Follow the steps, being very careful to resolve any <em>merge conflicts</em> if necessary.\n1) Push your rebased branch to your <code>origin</code>: <code>git push origin feat/my-cool-feature</code></p>\n<h2 id=\"gotchas\">Gotchas</h2>\n<p>Sometimes you will need to rebase your branch after you push it, because somebody else had made a change to the code and you need to update your branch before your PR can be merged. Just <code>fetch</code> the latest changes, and <code>rebase</code> as above. When this happens, you may encounter an error when you go to push your code to your <code>origin</code>:</p>\n<pre><code>ADD ERROR HERE\n</code></pre><p>This is because rebasing <em>changes your commits</em>. Your updated commits (and any new ones) are no longer compatible with the commits you push before. You have to overwrite them:\n<code>git push origin feat/my-cool-feature -f</code>\nThe <code>-f</code> t the end of the commend tells git to do a &quot;force&quot; push, which replaces all the commits that are on the remote branch with your new rebased version.</p>\n<h2 id=\"check-your-understanding\">Check your understanding</h2>\n<ul>\n<li>How is a fork of a repository different than a clone?</li>\n<li>What are some reasons for forking?</li>\n<li>What do we mean by hard and soft forks?</li>\n</ul>\n<h2 id=\"more-resources\">More resources</h2>\n<p>Some further reading</p>\n<ul>\n<li><a href=\"https://help.github.com/articles/fork-a-repo/\">GitHub help article</a></li>\n<li><a href=\"TODO\">Atlassian&#39;s explanation</a></li>\n<li><a href=\"https://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/\">Another perspective on forks</a></li>\n</ul>\n"}},"siteProps":{"title":"React Static"}};</script><script async="" src="/app.e0969f35.js"></script></body></html>