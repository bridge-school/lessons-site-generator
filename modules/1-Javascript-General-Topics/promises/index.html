<!DOCTYPE html><html lang="en-US" data-reactroot=""><head><title data-react-helmet="true"></title><link rel="stylesheet" href="https://bridge-school.github.io/lessons-site-generator/styles.03aee10c.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/><link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css"/><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:500"/></head><body><div class="slug-home"><div id="root"><div data-reactroot=""><header class=" mdc-toolbar"><div class=" mdc-toolbar__row"><section class="brand  mdc-toolbar__section mdc-toolbar__section--align-start"><svg width="48" height="48" viewBox="0 0 1205 863" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>white bridge logo</title><desc>white bridge logo</desc><use xlink:href="#a" transform="translate(0 485.01)" fill="#FAFAFA"></use><use xlink:href="#b" transform="translate(246.1 572.65)" fill="#FAFAFA"></use><use xlink:href="#c" transform="translate(412.5 486)" fill="#FAFAFA"></use><use xlink:href="#d" transform="translate(522.1 486)" fill="#FAFAFA"></use><use xlink:href="#e" transform="translate(768.2 573.64)" fill="#FAFAFA"></use><use xlink:href="#f" transform="translate(1013.3 573.64)" fill="#FAFAFA"></use><g><use xlink:href="#g" transform="translate(198.3 1)" fill="#FAFAFA"></use><use xlink:href="#h" transform="translate(859.9)" fill="#FAFAFA"></use><use xlink:href="#i" transform="translate(382.6)" fill="#FAFAFA"></use><use xlink:href="#j" transform="translate(381.6 106.56)" fill="#FAFAFA"></use></g><defs><path id="a" d="M57.792 297.776H0V0h57.792v110.546c8.967-10.955 29.892-21.91 50.816-21.91 59.785 0 92.666 48.799 92.666 107.557 0 58.759-33.878 106.562-92.666 106.562-21.92 0-42.845-10.955-50.816-21.91v16.931zm0-68.718c6.974 13.943 21.92 23.902 37.863 23.902 30.889 0 48.824-24.898 48.824-57.763 0-32.864-17.935-57.762-48.824-57.762-15.942 0-31.885 9.959-37.863 23.902v67.721z"></path><path id="b" d="M125.547 61.746c-7.971-4.98-17.935-6.971-28.895-6.971-18.932 0-34.875 9.959-39.857 28.881v126.48H0V4.98h56.795v19.918C65.763 9.959 82.702 0 102.63 0c9.964 0 17.935 1.992 21.921 2.988l.996 58.758z"></path><path id="c" d="M33.878 65.73C15.943 65.73 0 52.783 0 32.865 0 14.939 14.946 0 33.878 0c17.935 0 33.878 12.947 33.878 32.865-.997 19.918-16.94 32.865-33.878 32.865zm27.9 231.05H4.981V92.62h56.795v204.16z"></path><path id="d" d="M143.483 279.849c-8.968 10.955-29.893 21.91-50.817 21.91C32.88 301.759 0 253.956 0 195.197 0 136.439 33.878 87.64 92.666 87.64c21.921 0 42.845 10.955 50.817 21.91V0h57.791v297.776h-57.791v-17.927zm0-118.512c-6.975-12.947-21.921-23.902-37.864-23.902-30.888 0-48.824 24.897-48.824 57.762s17.936 57.763 48.824 57.763c16.939 0 31.885-9.959 37.864-23.902v-67.721z"></path><path id="e" d="M142.486 184.242c-8.967 10.955-27.899 20.914-49.82 20.914C32.882 205.156 0 157.353 0 102.578 0 47.803 33.878 0 92.666 0c22.917 0 40.853 9.959 49.82 19.918V3.984h56.795v182.25c0 69.714-42.845 102.578-100.637 102.578-52.81 0-89.676-26.889-95.655-72.701h54.803c4.982 18.923 17.935 28.882 39.856 28.882 28.896 0 43.842-16.931 43.842-49.796l.996-10.955zm0-115.524c-6.975-11.951-21.921-20.915-37.863-20.915-30.889 0-47.828 22.906-47.828 54.775s17.936 54.775 47.828 54.775c16.939 0 31.885-9.959 37.863-21.91V68.717z"></path><path id="f" d="M190.314 142.414c-7.972 42.824-39.857 71.706-90.673 71.706C39.856 214.12 0 171.296 0 107.558 0 44.816 40.853 0 98.644 0c60.781 0 92.666 40.832 92.666 101.582v16.931H54.802c1.993 30.873 18.932 48.799 43.842 48.799 18.932 0 33.878-7.967 37.864-25.893l53.806.995zM56.795 84.652h78.716c0-21.91-12.953-37.844-36.867-37.844-21.92 0-37.863 12.946-41.849 37.844z"></path><path id="g" d="M85.69 302.755c0 8.963 4.983 13.943 13.95 13.943h46.832v42.824H99.641c-36.867 0-62.774-23.902-62.774-60.75V214.12c0-8.964-4.982-13.943-13.95-13.943H0v-43.82h23.914c8.967 0 13.95-4.979 13.95-13.943V60.75C37.863 22.906 63.77 0 100.636 0h45.835v42.824H99.641c-8.968 0-13.95 4.98-13.95 13.943v80.668c0 20.914-9.964 31.869-22.917 39.836 12.953 7.967 22.917 18.922 22.917 39.836v85.648z"></path><path id="h" d="M60.78 217.107c0-20.914 9.965-31.869 22.918-39.836-12.953-7.967-22.917-18.922-22.917-39.836V55.771c0-8.963-4.982-13.943-13.95-13.943H0V0h45.835c36.867 0 62.773 23.902 62.773 60.75v79.673c0 8.963 4.982 13.942 13.95 13.942h23.914v44.816h-23.914c-8.968 0-13.95 4.98-13.95 13.943v84.652c0 37.844-25.906 60.75-62.773 60.75H0v-42.824h46.831c8.968 0 13.95-4.98 13.95-13.943v-84.652z"></path><path id="i" d="M220.206 0H0v41.828H439.415V0H220.206z"></path><path id="j" d="M374.649 210.136v-59.754C374.649 65.73 307.89 0 222.199 0h-3.986c-85.691 0-152.45 65.73-152.45 150.382v59.754H0v42.824h107.612V151.378c0-60.75 48.824-108.554 110.601-108.554h3.986c61.777 0 110.601 47.803 110.601 108.554V252.96h107.612v-42.824h-65.763z"></path></defs></svg></section><section class="navigation  mdc-toolbar__section"><nav><a href="https://bridge-school.github.io/lessons-site-generator/">Modules</a><a href="https://bridge-school.github.io/lessons-site-generator/about">About</a></nav></section></div></header><div class="content"><div><a href="https://bridge-school.github.io/lessons-site-generator/"><button class=" mdc-button mdc-button--stroked">Back to Modules</button></a><br/><h3>Promises</h3><p><h2 id="promises">Promises</h2>
<p>Promises are now officially in Javascript, as of ES2015! So we should probably try and figure out what promises are.</p>
<p>First, let&#39;s talk about the problem that Promises are solving. In javascript, asynchronous code (that&#39;s code that does not immediately fire)
has always been complicated and difficult to deal with. Today there are a lot of different methods to do so, there are Promises, Observables, Generators and often a combination of all of these and more.
So what are these systems, tools and libraries trying to do? Well, let&#39;s talk about just how javascript <strong>runs</strong>. </p>
<p>In Javascript, code is run in a single threaded manner (let&#39;s not get into WebWorkers right now) - meaning, that all code is run by the 
same thread of thought, so to speak. That means everything needs to queue up and wait it&#39;s turn, and no skipping in the line.</p>
<p>This get&#39;s complicated when you have async code. Let&#39;s take a look at <code>setTimeout</code>.</p>
<pre><code class="lang-javascript">const someValue = &#39;Hello&#39;;
let theSecondHalf = &#39;&#39;;
setTimeout(() =&gt; theSecondHalf = &#39;World&#39;, 0);
console.log(someValue + theSecondHalf);
</code></pre>
<p>Well, looking at this code, some might intuitively think &quot;well, we have someValue equalling Hello, theSecondHalf being blank
at first but on the next line we give it a value, then right after that we give it a value of &#39;world&#39; so then on the last line it should say &#39;HelloWorld&#39; in the console.&quot;.</p>
<p>The reasoning above seems right, but this is where the complicated nature of async code comes in. SetTimeout, no matter what, is an asynchronous action. That means no matter what,
the function inside is <strong>not</strong> part of the immediate stack. It get&#39;s put in the queue and is called at the next available opportunity (when the current stack clears).</p>
<p>So that means that <code>console.log()</code> fires <em>before</em> the function that sets <code>theSecondHalf</code> to &#39;World&#39; does.</p>
<p>Now this can be annoying, especially if I don&#39;t have any control over when the async event is firing - like with a network request. So promises are a way to communicate better with these
async events. Now, what we do, is wait for our async events.</p>
<h3 id="our-first-promise">Our first promise</h3>
<pre><code class="lang-javascript">let myPromise = new Promise((res, rej) =&gt; setTimeout(()=&gt; res(&#39;yay&#39;), 3000));

myPromise.then(response =&gt; console.log(response));
</code></pre>
<p>So let&#39;s break this down a little bit. First, let&#39;s take a look at this <code>new</code> keyword. We seem to be calling it right in front of a function - and this tells us the function is a <code>constructor</code>.
I won&#39;t get into the details of what that entails, but just know that a constructor is a special kind of function that always returns an object. This object, in this case, is a <code>Promise</code>. So that means
that &#39;myPromise&#39; ends up equalling a promise object, which comes with a few useful methods, one of which we&#39;ll get into later.</p>
<p>Now this promise is getting something passed into it - and that is a function, specifically:</p>
<pre><code class="lang-javascript">(res, rej) =&gt; setTimeout(()=&gt; res(&#39;yay&#39;), 3000)
</code></pre>
<p>This is passed into the Promise, and it is a callback function, which if you remember is a function definition passed into another function. Additionally,
any function you pass into a Promise constructor can expect two parameters to be passed in. This is where it gets tricky - the two parameters that you can expect are
<strong><em>also</em></strong> functions. You can see that in this example, we are even calling one of them, <code>res</code>. If you&#39;re not confused at this point, congratulations, you&#39;re a loooot smarter than me. This can get really dicey,
 and this is why we&#39;ll continue to go over the fundamentals of a function. Anyway, this res - what is it doing? Well we can see that inside of the callback function above,
 we are calling <code>setTimeout</code>, and waiting 3 seconds (3000ms) before firing the res function inside. So what that looks like is, 3 seconds after we create the function,
 <code>res</code> is fired, and additionally, it is provided the value <code>&#39;yay&#39;</code>. So that looks cool - but how does that practically change or do anything? Well this is where we get 
 back to that <code>myPromise</code> variable:</p>
<pre><code class="lang-javascript">myPromise.then(response =&gt; console.log(response));
</code></pre>
<p>Right here, we can see that myPromise, the promise object returned by the promise constructor, has a cool function that comes with it called <code>then</code>. We didn&#39;t define this, all
promises come with it. What <code>then</code> does can be a little confusing, because we can see that it <strong><em>also expects a callback</em></strong>. This callback function has one specific purpose though.</p>
<h3 id="what-is-then-doing-">What is &#39;then&#39; doing?</h3>
<p>So <code>then</code> takes a function as it&#39;s first (and second, but we&#39;ll get into it later), parameter. <em>This function get&#39;s called right after the resolve in the promise constructor get&#39;s called</em>. Meaning, in the 
example above, it get&#39;s called 3 seconds after myPromise get&#39;s defined! You can also see that this callback function expects something as well, and we are console logging that result.</p>
<p>Can you guess what that result is? It&#39;s &#39;yay&#39;! That same string I passed in the constructor is available, three seconds later, in this function.</p>
<p>This may seem a bit useless, and in this example it really is, but when we get to RESTful calls, you&#39;ll see it&#39;s value. In the next less on promises, we&#39;ll talk about the <code>reject</code> that we conveniently avoided today!</p>
</p></div></div></div></div></div><script type="text/javascript">
                window.__routeData = {"path":"/modules/1-Javascript-General-Topics/promises","propsMap":{"__local":"2hE3VA"},"initialProps":{"module":{"contents":{"data":{}},"title":"Promises","path":"1-Javascript-General-Topics/promises","id":"promises","body":"<h2 id=\"promises\">Promises</h2>\n<p>Promises are now officially in Javascript, as of ES2015! So we should probably try and figure out what promises are.</p>\n<p>First, let&#39;s talk about the problem that Promises are solving. In javascript, asynchronous code (that&#39;s code that does not immediately fire)\nhas always been complicated and difficult to deal with. Today there are a lot of different methods to do so, there are Promises, Observables, Generators and often a combination of all of these and more.\nSo what are these systems, tools and libraries trying to do? Well, let&#39;s talk about just how javascript <strong>runs</strong>. </p>\n<p>In Javascript, code is run in a single threaded manner (let&#39;s not get into WebWorkers right now) - meaning, that all code is run by the \nsame thread of thought, so to speak. That means everything needs to queue up and wait it&#39;s turn, and no skipping in the line.</p>\n<p>This get&#39;s complicated when you have async code. Let&#39;s take a look at <code>setTimeout</code>.</p>\n<pre><code class=\"lang-javascript\">const someValue = &#39;Hello&#39;;\nlet theSecondHalf = &#39;&#39;;\nsetTimeout(() =&gt; theSecondHalf = &#39;World&#39;, 0);\nconsole.log(someValue + theSecondHalf);\n</code></pre>\n<p>Well, looking at this code, some might intuitively think &quot;well, we have someValue equalling Hello, theSecondHalf being blank\nat first but on the next line we give it a value, then right after that we give it a value of &#39;world&#39; so then on the last line it should say &#39;HelloWorld&#39; in the console.&quot;.</p>\n<p>The reasoning above seems right, but this is where the complicated nature of async code comes in. SetTimeout, no matter what, is an asynchronous action. That means no matter what,\nthe function inside is <strong>not</strong> part of the immediate stack. It get&#39;s put in the queue and is called at the next available opportunity (when the current stack clears).</p>\n<p>So that means that <code>console.log()</code> fires <em>before</em> the function that sets <code>theSecondHalf</code> to &#39;World&#39; does.</p>\n<p>Now this can be annoying, especially if I don&#39;t have any control over when the async event is firing - like with a network request. So promises are a way to communicate better with these\nasync events. Now, what we do, is wait for our async events.</p>\n<h3 id=\"our-first-promise\">Our first promise</h3>\n<pre><code class=\"lang-javascript\">let myPromise = new Promise((res, rej) =&gt; setTimeout(()=&gt; res(&#39;yay&#39;), 3000));\n\nmyPromise.then(response =&gt; console.log(response));\n</code></pre>\n<p>So let&#39;s break this down a little bit. First, let&#39;s take a look at this <code>new</code> keyword. We seem to be calling it right in front of a function - and this tells us the function is a <code>constructor</code>.\nI won&#39;t get into the details of what that entails, but just know that a constructor is a special kind of function that always returns an object. This object, in this case, is a <code>Promise</code>. So that means\nthat &#39;myPromise&#39; ends up equalling a promise object, which comes with a few useful methods, one of which we&#39;ll get into later.</p>\n<p>Now this promise is getting something passed into it - and that is a function, specifically:</p>\n<pre><code class=\"lang-javascript\">(res, rej) =&gt; setTimeout(()=&gt; res(&#39;yay&#39;), 3000)\n</code></pre>\n<p>This is passed into the Promise, and it is a callback function, which if you remember is a function definition passed into another function. Additionally,\nany function you pass into a Promise constructor can expect two parameters to be passed in. This is where it gets tricky - the two parameters that you can expect are\n<strong><em>also</em></strong> functions. You can see that in this example, we are even calling one of them, <code>res</code>. If you&#39;re not confused at this point, congratulations, you&#39;re a loooot smarter than me. This can get really dicey,\n and this is why we&#39;ll continue to go over the fundamentals of a function. Anyway, this res - what is it doing? Well we can see that inside of the callback function above,\n we are calling <code>setTimeout</code>, and waiting 3 seconds (3000ms) before firing the res function inside. So what that looks like is, 3 seconds after we create the function,\n <code>res</code> is fired, and additionally, it is provided the value <code>&#39;yay&#39;</code>. So that looks cool - but how does that practically change or do anything? Well this is where we get \n back to that <code>myPromise</code> variable:</p>\n<pre><code class=\"lang-javascript\">myPromise.then(response =&gt; console.log(response));\n</code></pre>\n<p>Right here, we can see that myPromise, the promise object returned by the promise constructor, has a cool function that comes with it called <code>then</code>. We didn&#39;t define this, all\npromises come with it. What <code>then</code> does can be a little confusing, because we can see that it <strong><em>also expects a callback</em></strong>. This callback function has one specific purpose though.</p>\n<h3 id=\"what-is-then-doing-\">What is &#39;then&#39; doing?</h3>\n<p>So <code>then</code> takes a function as it&#39;s first (and second, but we&#39;ll get into it later), parameter. <em>This function get&#39;s called right after the resolve in the promise constructor get&#39;s called</em>. Meaning, in the \nexample above, it get&#39;s called 3 seconds after myPromise get&#39;s defined! You can also see that this callback function expects something as well, and we are console logging that result.</p>\n<p>Can you guess what that result is? It&#39;s &#39;yay&#39;! That same string I passed in the constructor is available, three seconds later, in this function.</p>\n<p>This may seem a bit useless, and in this example it really is, but when we get to RESTful calls, you&#39;ll see it&#39;s value. In the next less on promises, we&#39;ll talk about the <code>reject</code> that we conveniently avoided today!</p>\n"}},"siteProps":{"title":"React Static"}};</script><script async="" src="/app.03aee10c.js"></script></body></html>