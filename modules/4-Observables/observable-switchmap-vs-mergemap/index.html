<!DOCTYPE html><html lang="en-US" data-reactroot=""><head><title data-react-helmet="true"></title><link rel="stylesheet" href="https://g2graman.github.io/bridge-modules/styles.6ce5e406.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/><link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css"/><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:500"/></head><body><div class="slug-home"><div id="root"><div data-reactroot=""><header class=" mdc-toolbar"><div class=" mdc-toolbar__row"><section class="brand  mdc-toolbar__section mdc-toolbar__section--align-start"><svg width="48" height="48" viewBox="0 0 1205 863" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>white bridge logo</title><desc>white bridge logo</desc><use xlink:href="#a" transform="translate(0 485.01)" fill="#FAFAFA"></use><use xlink:href="#b" transform="translate(246.1 572.65)" fill="#FAFAFA"></use><use xlink:href="#c" transform="translate(412.5 486)" fill="#FAFAFA"></use><use xlink:href="#d" transform="translate(522.1 486)" fill="#FAFAFA"></use><use xlink:href="#e" transform="translate(768.2 573.64)" fill="#FAFAFA"></use><use xlink:href="#f" transform="translate(1013.3 573.64)" fill="#FAFAFA"></use><g><use xlink:href="#g" transform="translate(198.3 1)" fill="#FAFAFA"></use><use xlink:href="#h" transform="translate(859.9)" fill="#FAFAFA"></use><use xlink:href="#i" transform="translate(382.6)" fill="#FAFAFA"></use><use xlink:href="#j" transform="translate(381.6 106.56)" fill="#FAFAFA"></use></g><defs><path id="a" d="M57.792 297.776H0V0h57.792v110.546c8.967-10.955 29.892-21.91 50.816-21.91 59.785 0 92.666 48.799 92.666 107.557 0 58.759-33.878 106.562-92.666 106.562-21.92 0-42.845-10.955-50.816-21.91v16.931zm0-68.718c6.974 13.943 21.92 23.902 37.863 23.902 30.889 0 48.824-24.898 48.824-57.763 0-32.864-17.935-57.762-48.824-57.762-15.942 0-31.885 9.959-37.863 23.902v67.721z"></path><path id="b" d="M125.547 61.746c-7.971-4.98-17.935-6.971-28.895-6.971-18.932 0-34.875 9.959-39.857 28.881v126.48H0V4.98h56.795v19.918C65.763 9.959 82.702 0 102.63 0c9.964 0 17.935 1.992 21.921 2.988l.996 58.758z"></path><path id="c" d="M33.878 65.73C15.943 65.73 0 52.783 0 32.865 0 14.939 14.946 0 33.878 0c17.935 0 33.878 12.947 33.878 32.865-.997 19.918-16.94 32.865-33.878 32.865zm27.9 231.05H4.981V92.62h56.795v204.16z"></path><path id="d" d="M143.483 279.849c-8.968 10.955-29.893 21.91-50.817 21.91C32.88 301.759 0 253.956 0 195.197 0 136.439 33.878 87.64 92.666 87.64c21.921 0 42.845 10.955 50.817 21.91V0h57.791v297.776h-57.791v-17.927zm0-118.512c-6.975-12.947-21.921-23.902-37.864-23.902-30.888 0-48.824 24.897-48.824 57.762s17.936 57.763 48.824 57.763c16.939 0 31.885-9.959 37.864-23.902v-67.721z"></path><path id="e" d="M142.486 184.242c-8.967 10.955-27.899 20.914-49.82 20.914C32.882 205.156 0 157.353 0 102.578 0 47.803 33.878 0 92.666 0c22.917 0 40.853 9.959 49.82 19.918V3.984h56.795v182.25c0 69.714-42.845 102.578-100.637 102.578-52.81 0-89.676-26.889-95.655-72.701h54.803c4.982 18.923 17.935 28.882 39.856 28.882 28.896 0 43.842-16.931 43.842-49.796l.996-10.955zm0-115.524c-6.975-11.951-21.921-20.915-37.863-20.915-30.889 0-47.828 22.906-47.828 54.775s17.936 54.775 47.828 54.775c16.939 0 31.885-9.959 37.863-21.91V68.717z"></path><path id="f" d="M190.314 142.414c-7.972 42.824-39.857 71.706-90.673 71.706C39.856 214.12 0 171.296 0 107.558 0 44.816 40.853 0 98.644 0c60.781 0 92.666 40.832 92.666 101.582v16.931H54.802c1.993 30.873 18.932 48.799 43.842 48.799 18.932 0 33.878-7.967 37.864-25.893l53.806.995zM56.795 84.652h78.716c0-21.91-12.953-37.844-36.867-37.844-21.92 0-37.863 12.946-41.849 37.844z"></path><path id="g" d="M85.69 302.755c0 8.963 4.983 13.943 13.95 13.943h46.832v42.824H99.641c-36.867 0-62.774-23.902-62.774-60.75V214.12c0-8.964-4.982-13.943-13.95-13.943H0v-43.82h23.914c8.967 0 13.95-4.979 13.95-13.943V60.75C37.863 22.906 63.77 0 100.636 0h45.835v42.824H99.641c-8.968 0-13.95 4.98-13.95 13.943v80.668c0 20.914-9.964 31.869-22.917 39.836 12.953 7.967 22.917 18.922 22.917 39.836v85.648z"></path><path id="h" d="M60.78 217.107c0-20.914 9.965-31.869 22.918-39.836-12.953-7.967-22.917-18.922-22.917-39.836V55.771c0-8.963-4.982-13.943-13.95-13.943H0V0h45.835c36.867 0 62.773 23.902 62.773 60.75v79.673c0 8.963 4.982 13.942 13.95 13.942h23.914v44.816h-23.914c-8.968 0-13.95 4.98-13.95 13.943v84.652c0 37.844-25.906 60.75-62.773 60.75H0v-42.824h46.831c8.968 0 13.95-4.98 13.95-13.943v-84.652z"></path><path id="i" d="M220.206 0H0v41.828H439.415V0H220.206z"></path><path id="j" d="M374.649 210.136v-59.754C374.649 65.73 307.89 0 222.199 0h-3.986c-85.691 0-152.45 65.73-152.45 150.382v59.754H0v42.824h107.612V151.378c0-60.75 48.824-108.554 110.601-108.554h3.986c61.777 0 110.601 47.803 110.601 108.554V252.96h107.612v-42.824h-65.763z"></path></defs></svg></section><section class="navigation  mdc-toolbar__section"><nav><a href="https://g2graman.github.io/bridge-modules/">Modules</a><a href="https://g2graman.github.io/bridge-modules/about">About</a></nav></section></div></header><div class="content"><div><a href="https://g2graman.github.io/bridge-modules/"><button class=" mdc-button mdc-button--stroked">Back to Modules</button></a><br/><h3>Observable Switchmap Vs Mergemap</h3><p><h1 id="switchmap-vs-mergemap">SwitchMap vs MergeMap</h1>
<p>SwitchMap and MergeMap are smiliar operators, they&#39;re your go-to when you need to combine streams. Knowing the who, what, and why between these two operators will help you pick the right one for the job. Let&#39;s start with their similarites:</p>
<h4 id="switchmap">SwitchMap</h4>
<p>SwitchMap is an operator that maps the values emitted from an observable to a different observable.</p>
<h4 id="mergemap">MergeMap</h4>
<p>MergeMap is an operator that maps the values emitted from an observable to a different observable.</p>
<hr>
<p>Pretty <del>similar</del> identical so far, right? There <em>are</em> differences, but I&#39;ll save those for later.  Let&#39;s first pick apart this definition and then move to the differences. </p>
<h4 id="switchmap-mergemap">SwitchMap &amp; MergeMap</h4>
<p>SwitchMap <em>and</em> MergeMap are operators that map the values emitted from an observable to a different observable.</p>
<p>To start, let&#39;s break apart SwitchMap and MergeMap into the individual <strong>verbs</strong> that make them up: </p>
<table>
<thead>
<tr>
<th>Verb</th>
<th style="text-align:center">What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map</td>
<td style="text-align:center">?</td>
<td></td>
</tr>
<tr>
<td>Merge</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td>Switch</td>
<td style="text-align:center">?</td>
</tr>
</tbody>
</table>
<h4 id="map">Map</h4>
<p>When you see <strong>map</strong> you can read it as: </p>
<blockquote>
<p>Use the value of something to change it to something else.</p>
</blockquote>
<p>To expand on this, consider this tragic hypothetical. Imagine a world where there are no dogs. Only cats. At one point there <em>were</em> dogs, but somewhere in time CatConverter was created.  CatConverter is a machine that takes a group of dogs and converts them to cats! </p>
<pre><code class="lang-javascript">const dogs$ = Rx.Observable.from([
  { name: &#39;sam&#39;, animal: &#39;dog&#39;, fur: &#39;brown&#39; },
  { name: &#39;fluffy&#39;, animal: &#39;dog&#39;, fur: &#39;orange&#39; },
  { name: &#39;jen&#39; , animal: &#39;dog&#39;, fur: &#39;black&#39; },
]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(500))

const CatConverter = (dogs) =&gt; Rx.Observable.from(dogs)
    .map((dog) =&gt; `Plain old cat`);

CatConverter(dogs$)
</code></pre>
<p><a target="_blank" href="https://rxviz.com/v/2ORwP2Jd">Run this code</a></p>
<p>This CatConverter takes a list of dogs and converts them to cats.  But it&#39;s not making use of the &quot;<em><strong>value of something</strong></em>&quot; from our map definition above:</p>
<blockquote>
<p>Use the <em><strong>value of something</strong></em> to change it to something else.  </p>
</blockquote>
<p>Instead it&#39;s recieving a dog and returning a plain old cat. </p>
<p>Let&#39;s update CatConverter so that instead of converting dogs to plain old cats, it creates cats with different colour fur. It will use the fur from the dog to create the cat.  (That sounds dark) </p>
<pre><code class="lang-diff">const dogs$ = Rx.Observable.from([
  { name: &#39;sam&#39;, animal: &#39;dog&#39;, fur: &#39;brown&#39; },
  { name: &#39;fluffy&#39;, animal: &#39;dog&#39;, fur: &#39;orange&#39; },
  { name: &#39;jen&#39; , animal: &#39;dog&#39;, fur: &#39;black&#39; },
]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(500))

const CatConverter = (dogs) =&gt; Rx.Observable.from(dogs)
+    .map((dog) =&gt; `${dog.fur} cat`);

CatConverter(dogs$)
</code></pre>
<p><a target="_blank" href="https://rxviz.com/v/L8k6Y2J7">Run this code</a>.</p>
<p>Notice the update to CatConverter? Now it uses the fur of the dog to determine the cat&#39;s colour.</p>
<p>Now our definition for map makes sense:</p>
<blockquote>
<p>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>. </p>
</blockquote>
<p>A.K.A</p>
<blockquote>
<p>Use the <em><strong>colour of the dog&#39;s fur</strong></em> to change the dog to a <em><strong>cat with the dog&#39;s fur colour</strong></em>. </p>
</blockquote>
<p>It helps to keep this definition in mind because there are numourouse Rx operators that have the word <strong>map</strong> tacked on to the end. And it&#39;s always for the same reason: &quot;To use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.&quot;</p>
<h5 id="operators-with-map">Operators with map</h5>
<ul>
<li>map</li>
<li>concatMap</li>
<li>exhaustMap</li>
<li>mergeMap</li>
<li>switchMap</li>
</ul>
<p>Update the verbs with our map definition:</p>
<table>
<thead>
<tr>
<th>Verb</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map</td>
<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>
<td></td>
</tr>
<tr>
<td>Merge</td>
<td>?</td>
</tr>
<tr>
<td>Switch</td>
<td>?</td>
</tr>
</tbody>
</table>
<h3 id="merge">Merge</h3>
<p>Next verb in the list is merge.</p>
<blockquote>
<p>Merge takes two or more observable streams and combines them together.</p>
</blockquote>
<p>With that, come back to our world where there are cats <em>and</em> dogs.</p>
<pre><code class="lang-javascript">const dogs$ = Rx.Observable.from([
  &#39;🐶 Rover&#39;,
  &#39;🐶 Mr Muffin&#39;,
  &#39;🐶 Huck&#39;,
]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(1000))

const cats$ = Rx.Observable.from([
  &#39;🐱 Precious&#39;,
  &#39;🐱 Mittens&#39;,
  &#39;🐱 Garfield&#39;,
]).concatMap(cat =&gt; Rx.Observable.of(cat).delay(400))

Rx.Observable.merge(
  dogs$,
  cats$
);
</code></pre>
<p><a target="_blank" href="https://rxviz.com/v/RoQB01OM">Run this code</a>.</p>
<p>Looking at these two streams individually can be represented by these two marble diagrams:</p>
<p><strong>dogs$:</strong><code>|-----d-----d-----d--------&gt;</code></p>
<p><strong>cats$:</strong> <code>|-c--c--c------------------&gt;</code></p>
<p>Each letter represents an emission <em>over time</em>.  </p>
<p>Time? Yes, notice in the code snippit that the <code>dogs$</code> stream emits one dog every 1 second. And the <code>cats$</code> stream emits one cat every 0.4 of a second. Apparently cats are faster than dogs.</p>
<p>Using <code>merge()</code> at the end of the snippit, we flatten these two streams into one stream. If you line everything up, that&#39;s visually easy to see:</p>
<p><strong>dogs$:</strong><code>|-----d-----d-----d--------&gt;</code></p>
<p><strong>cats$:</strong> <code>|-c--c--c------------------&gt;</code></p>
<p><code>merge()</code></p>
<p><strong>both$:</strong> <code>|-c--cd-c--d-----d---------&gt;</code></p>
<p>See how the dogs on the <code>$dogs</code> stream line up with the dogs on the <code>both$</code> stream and the cats on the <code>cats$</code> stream line up with the cats on the <code>both$</code> stream? That&#39;s a merge.</p>
<p>Update the verbs with our merge definition:</p>
<table>
<thead>
<tr>
<th>Verb</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map</td>
<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>
<td></td>
</tr>
<tr>
<td>Merge</td>
<td>Merge takes two or more observable streams and <em><strong>combines</strong></em> them together.</td>
</tr>
<tr>
<td>Switch</td>
<td>?</td>
</tr>
</tbody>
</table>
<h3 id="switch">Switch</h3>
<p>Last verb on the list is switch.</p>
<blockquote>
<p>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the orignal stream at each emission and changes to the new emitted stream.  At every subsequent emission from the root stream, it will stop listening to the previouse child stream. </p>
</blockquote>
<p>This is the tougher one of the bunch to understand based off the description, so let&#39;s jump to the cats and the dogs. </p>
<p>Remember CatConverter? It&#39;s causing a pretty big imbalance in the universe.  Let&#39;s hack that thing. We&#39;re going to change it to an AnimalCloner! This way, any animal that wanders into the machine will get cloned every 100th of a second until the next animal wanders in. What could go wrong? Balance will be restored. </p>
<pre><code class="lang-javascript">const dogClones$ = Rx.Observable.interval(100).mapTo(&#39;🐶&#39;);
const catClones$ = Rx.Observable.interval(100).mapTo(&#39;🐱&#39;);

const catsAndDogs$ = Rx.Observable.from([
  dogClones$,
  dogClones$,
  catClones$,
  dogClones$,
  catClones$,
]).concatMap(animals$ =&gt; Rx.Observable.of(animals$).delay(1000));

const AnimalCloner = (animals$) =&gt; animals$;

AnimalCloner(catsAndDogs$);
</code></pre>
<p><a target="_blank" href="https://rxviz.com/v/6Jrz26JG">Run this code</a></p>
<p>First thing to note here is that it does NOT use the switch operator.  And has caused chaos:</p>
<pre><code class="lang-javascript">|------d$------d$------c$------d$------c$---------&gt;
       |
       |-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶&gt;
                   |
                   |-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-&gt;
                         |
                         |-🐱-🐱-🐱-🐱-🐱-🐱-🐱-🐱-&gt;
                                 |
                                 |-🐶-🐶-🐶-🐶-🐶-🐶&gt;
                                        |
                                        |-🐱-🐱-🐱-🐱&gt;
</code></pre>
<p>AnimalCloner is out of control. What we want is <em>one</em> stream of animals for each time an animal enters the cloner. Instead we end up with <em>multiple</em> streams. <code>Switch</code> to the rescue, but first we need to make sure we understand why there are multiple streams here.</p>
<p><code>dogClones$</code>: This is a stream of dogs that emit every 100th of a second</p>
<p><code>catClones$</code>: This is a stream of cats that emit every 100th of a second</p>
<p><code>catsAndDogs$</code>: This is a stream that emits a mix of <strong>dogClones$</strong> and <strong>catClones$</strong> every second. The important take-away here is that this is a <strong>stream of streams</strong>.  That&#39;s why when we pass <code>catsAndDogs$</code> into <code>AnimalCloner()</code> we get that nasty barage of streams. What we want is one stream.  And this is exactly what&#39;s missing from the <strong>switch</strong> description:</p>
<blockquote>
<p>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the original stream at each emission and change to the new emitted stream.  At <em><strong>every subsequent emission from the root stream, it will stop listening to the previous child stream</strong></em>.  </p>
</blockquote>
<p>Let&#39;s add <code>switch()</code>.</p>
<pre><code class="lang-javascript">const dogClones$ = Rx.Observable.interval(100).mapTo(&#39;🐶&#39;);
const catClones$ = Rx.Observable.interval(100).mapTo(&#39;🐱&#39;);

const catsAndDogs$ = Rx.Observable.from([
  dogClones$,
  dogClones$,
  catClones$,
  dogClones$,
  catClones$,
]).concatMap(animals$ =&gt; Rx.Observable.of(animals$).delay(1000));

const AnimalCloner = (animals$) =&gt; animals$;

AnimalCloner(catsAndDogs$).switch();
</code></pre>
<p><a target="_blank" href="https://rxviz.com/v/38MYm38v">Run this code</a></p>
<p>Fixed. Now it&#39;s just one nice stream that <em>switches</em> to the latest dog or cat stream over time. </p>
<pre><code class="lang-javascript">|------d$------d$------c$------d$------c$---------&gt;
       |
       |-🐶-🐶-🐶-🐶-🐱-🐱-🐱-🐶-🐶-🐶--🐱-🐱-🐱&gt;
</code></pre>
<p>Update the verbs with our switch definition:</p>
<table>
<thead>
<tr>
<th>Verb</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map</td>
<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>
<td></td>
</tr>
<tr>
<td>Merge</td>
<td>Merge takes two or more observable streams and <em><strong>combines</strong></em> them together.</td>
</tr>
<tr>
<td>Switch</td>
<td>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the original stream at each emission and changes to the new emitted stream.  At every subsequent emission from the root stream, it will stop listening to the previous child stream.</td>
</tr>
</tbody>
</table>
<h3 id="mergemap-switchmap">MergeMap &amp; SwitchMap</h3>
<p>Now that we have all the verbs defined, we can combine the definitions together to understand these two operators. </p>
<h5 id="mergemap">MergeMap</h5>
<blockquote>
<p>MergeMap changes (maps) the values emitted from one stream to a new stream.  It combines (merges) all the new streams into one stream. </p>
</blockquote>
<h5 id="switchmap">SwitchMap</h5>
<blockquote>
<p>SwitchMap changes (maps) the values emitted from one stream to a new stream.  It stops listening to the previous stream and changes (switches) to the next stream. </p>
</blockquote>
<p>Let&#39;s see these in action, but this time I&#39;ll go with a more real-world example.</p>
<p>Consider a chat app. The app has a list of users that you can click on to begin listening to their messages. At any point, you can click a different user to begin seeing their messages instead. In Observable land, this could look like:</p>
<pre><code class="lang-javascript">const kim = document.createElement(&#39;input&#39;);
const bob = document.createElement(&#39;input&#39;);
output.prepend(kim)
output.prepend(bob)

kim.setAttribute(&#39;type&#39;, &#39;button&#39;);
kim.setAttribute(&#39;value&#39;, &#39;kim&#39;);

bob.setAttribute(&#39;type&#39;, &#39;button&#39;);
bob.setAttribute(&#39;value&#39;, &#39;bob&#39;);

const chatStream$ = Rx.Observable.merge(
   Rx.Observable.fromEvent(kim, &#39;click&#39;),
   Rx.Observable.fromEvent(bob, &#39;click&#39;),
).mergeMap((clickEvent) =&gt; Rx.Observable
   .interval(800)
   .mapTo(`Hi from ${clickEvent.target.value}`)
);

chatStream$.map((message) =&gt; message);
</code></pre>
<p><a target="_blank" href="https://rxviz.com/v/jOLw0Boy">Run this code</a></p>
<p>This example attempts to accomplish the chat requirements with <strong>mergeMap</strong>. Stepping through the code, we can understand what&#39;s going on.</p>
<pre><code class="lang-javascript">const kim = document.createElement(&#39;input&#39;);
const bob = document.createElement(&#39;input&#39;);
output.prepend(kim)
output.prepend(bob)

kim.setAttribute(&#39;type&#39;, &#39;button&#39;);
kim.setAttribute(&#39;value&#39;, &#39;kim&#39;);

bob.setAttribute(&#39;type&#39;, &#39;button&#39;);
bob.setAttribute(&#39;value&#39;, &#39;bob&#39;);
</code></pre>
<p>This creates the html buttons and gives them a value of either &#39;kim&#39; or &#39;bob&#39;.</p>
<pre><code class="lang-javascript">
const chatStream$ = Rx.Observable.merge(
   Rx.Observable.fromEvent(kim, &#39;click&#39;),
   Rx.Observable.fromEvent(bob, &#39;click&#39;),
)
</code></pre>
<p>This creates two streams and combines them. The streams are (1) clicks from &#39;bob&#39; and (2) clicks from &#39;kim&#39;.</p>
<pre><code class="lang-javascript">const chatStream$ = Rx.Observable.merge(
   Rx.Observable.fromEvent(kim, &#39;click&#39;),
   Rx.Observable.fromEvent(bob, &#39;click&#39;),
).mergeMap((clickEvent) =&gt; Rx.Observable
   .interval(800)
   .mapTo(`Hi from ${clickEvent.target.value}`)
);
</code></pre>
<p>This <strong>mergeMap()&#39;s</strong> off the stream of clicks. Our definition of mergeMap tells us that it will <strong>change</strong> the value from the first stream of clicks into a <strong>new Observable</strong>.  The new Observable emits a message from the clicked user every 800th of a second. </p>
<p>Unlike <strong>switchMap</strong>, as clicks are emitted from the first stream, the previous child message stream never actually stops.  They just keep collecting over time! That gets pretty noisy. </p>
<p>Run the example and switch between bob and kim. You&#39;ll see each time you switch to a different user, the messages pile up. Clearly, we&#39;re not switching - we&#39;re merging!</p>
<p>We need to switch. Let&#39;s update:</p>
<pre><code class="lang-javascript">const kim = document.createElement(&#39;input&#39;);
const bob = document.createElement(&#39;input&#39;);
output.prepend(kim)
output.prepend(bob)

kim.setAttribute(&#39;type&#39;, &#39;button&#39;);
kim.setAttribute(&#39;value&#39;, &#39;kim&#39;);

bob.setAttribute(&#39;type&#39;, &#39;button&#39;);
bob.setAttribute(&#39;value&#39;, &#39;bob&#39;);

const chatStream$ = Rx.Observable.merge(
   Rx.Observable.fromEvent(kim, &#39;click&#39;),
   Rx.Observable.fromEvent(bob, &#39;click&#39;),
).switchMap((clickEvent) =&gt; Rx.Observable
   .interval(800)
   .mapTo(`Hi from ${clickEvent.target.value}`)
);

chatStream$.map((message) =&gt; message);
</code></pre>
<p><a target="_blank" href="https://rxviz.com/v/RoQBxAOM">Run this code</a></p>
<p>Switched! Run the example again and observe the new behaviour. It actually switches now. As you change from bob to kim, the stream stops listening to bob and <em><strong>switches</strong></em> to kim.</p>
</p></div></div></div></div></div><script type="text/javascript">
                window.__routeData = {"path":"/modules/4-Observables/observable-switchmap-vs-mergemap","propsMap":{"__local":"Z1XhqH6"},"initialProps":{"module":{"contents":{"data":{}},"title":"Observable Switchmap Vs Mergemap","path":"4-Observables/observable-switchmap-vs-mergemap","id":"observable-switchmap-vs-mergemap","body":"<h1 id=\"switchmap-vs-mergemap\">SwitchMap vs MergeMap</h1>\n<p>SwitchMap and MergeMap are smiliar operators, they&#39;re your go-to when you need to combine streams. Knowing the who, what, and why between these two operators will help you pick the right one for the job. Let&#39;s start with their similarites:</p>\n<h4 id=\"switchmap\">SwitchMap</h4>\n<p>SwitchMap is an operator that maps the values emitted from an observable to a different observable.</p>\n<h4 id=\"mergemap\">MergeMap</h4>\n<p>MergeMap is an operator that maps the values emitted from an observable to a different observable.</p>\n<hr>\n<p>Pretty <del>similar</del> identical so far, right? There <em>are</em> differences, but I&#39;ll save those for later.  Let&#39;s first pick apart this definition and then move to the differences. </p>\n<h4 id=\"switchmap-mergemap\">SwitchMap &amp; MergeMap</h4>\n<p>SwitchMap <em>and</em> MergeMap are operators that map the values emitted from an observable to a different observable.</p>\n<p>To start, let&#39;s break apart SwitchMap and MergeMap into the individual <strong>verbs</strong> that make them up: </p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th style=\"text-align:center\">What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td style=\"text-align:center\">?</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td style=\"text-align:center\">?</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td style=\"text-align:center\">?</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"map\">Map</h4>\n<p>When you see <strong>map</strong> you can read it as: </p>\n<blockquote>\n<p>Use the value of something to change it to something else.</p>\n</blockquote>\n<p>To expand on this, consider this tragic hypothetical. Imagine a world where there are no dogs. Only cats. At one point there <em>were</em> dogs, but somewhere in time CatConverter was created.  CatConverter is a machine that takes a group of dogs and converts them to cats! </p>\n<pre><code class=\"lang-javascript\">const dogs$ = Rx.Observable.from([\n  { name: &#39;sam&#39;, animal: &#39;dog&#39;, fur: &#39;brown&#39; },\n  { name: &#39;fluffy&#39;, animal: &#39;dog&#39;, fur: &#39;orange&#39; },\n  { name: &#39;jen&#39; , animal: &#39;dog&#39;, fur: &#39;black&#39; },\n]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(500))\n\nconst CatConverter = (dogs) =&gt; Rx.Observable.from(dogs)\n    .map((dog) =&gt; `Plain old cat`);\n\nCatConverter(dogs$)\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/2ORwP2Jd\">Run this code</a></p>\n<p>This CatConverter takes a list of dogs and converts them to cats.  But it&#39;s not making use of the &quot;<em><strong>value of something</strong></em>&quot; from our map definition above:</p>\n<blockquote>\n<p>Use the <em><strong>value of something</strong></em> to change it to something else.  </p>\n</blockquote>\n<p>Instead it&#39;s recieving a dog and returning a plain old cat. </p>\n<p>Let&#39;s update CatConverter so that instead of converting dogs to plain old cats, it creates cats with different colour fur. It will use the fur from the dog to create the cat.  (That sounds dark) </p>\n<pre><code class=\"lang-diff\">const dogs$ = Rx.Observable.from([\n  { name: &#39;sam&#39;, animal: &#39;dog&#39;, fur: &#39;brown&#39; },\n  { name: &#39;fluffy&#39;, animal: &#39;dog&#39;, fur: &#39;orange&#39; },\n  { name: &#39;jen&#39; , animal: &#39;dog&#39;, fur: &#39;black&#39; },\n]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(500))\n\nconst CatConverter = (dogs) =&gt; Rx.Observable.from(dogs)\n+    .map((dog) =&gt; `${dog.fur} cat`);\n\nCatConverter(dogs$)\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/L8k6Y2J7\">Run this code</a>.</p>\n<p>Notice the update to CatConverter? Now it uses the fur of the dog to determine the cat&#39;s colour.</p>\n<p>Now our definition for map makes sense:</p>\n<blockquote>\n<p>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>. </p>\n</blockquote>\n<p>A.K.A</p>\n<blockquote>\n<p>Use the <em><strong>colour of the dog&#39;s fur</strong></em> to change the dog to a <em><strong>cat with the dog&#39;s fur colour</strong></em>. </p>\n</blockquote>\n<p>It helps to keep this definition in mind because there are numourouse Rx operators that have the word <strong>map</strong> tacked on to the end. And it&#39;s always for the same reason: &quot;To use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.&quot;</p>\n<h5 id=\"operators-with-map\">Operators with map</h5>\n<ul>\n<li>map</li>\n<li>concatMap</li>\n<li>exhaustMap</li>\n<li>mergeMap</li>\n<li>switchMap</li>\n</ul>\n<p>Update the verbs with our map definition:</p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th>What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td>?</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td>?</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"merge\">Merge</h3>\n<p>Next verb in the list is merge.</p>\n<blockquote>\n<p>Merge takes two or more observable streams and combines them together.</p>\n</blockquote>\n<p>With that, come back to our world where there are cats <em>and</em> dogs.</p>\n<pre><code class=\"lang-javascript\">const dogs$ = Rx.Observable.from([\n  &#39;🐶 Rover&#39;,\n  &#39;🐶 Mr Muffin&#39;,\n  &#39;🐶 Huck&#39;,\n]).concatMap(dog =&gt; Rx.Observable.of(dog).delay(1000))\n\nconst cats$ = Rx.Observable.from([\n  &#39;🐱 Precious&#39;,\n  &#39;🐱 Mittens&#39;,\n  &#39;🐱 Garfield&#39;,\n]).concatMap(cat =&gt; Rx.Observable.of(cat).delay(400))\n\nRx.Observable.merge(\n  dogs$,\n  cats$\n);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/RoQB01OM\">Run this code</a>.</p>\n<p>Looking at these two streams individually can be represented by these two marble diagrams:</p>\n<p><strong>dogs$:</strong><code>|-----d-----d-----d--------&gt;</code></p>\n<p><strong>cats$:</strong> <code>|-c--c--c------------------&gt;</code></p>\n<p>Each letter represents an emission <em>over time</em>.  </p>\n<p>Time? Yes, notice in the code snippit that the <code>dogs$</code> stream emits one dog every 1 second. And the <code>cats$</code> stream emits one cat every 0.4 of a second. Apparently cats are faster than dogs.</p>\n<p>Using <code>merge()</code> at the end of the snippit, we flatten these two streams into one stream. If you line everything up, that&#39;s visually easy to see:</p>\n<p><strong>dogs$:</strong><code>|-----d-----d-----d--------&gt;</code></p>\n<p><strong>cats$:</strong> <code>|-c--c--c------------------&gt;</code></p>\n<p><code>merge()</code></p>\n<p><strong>both$:</strong> <code>|-c--cd-c--d-----d---------&gt;</code></p>\n<p>See how the dogs on the <code>$dogs</code> stream line up with the dogs on the <code>both$</code> stream and the cats on the <code>cats$</code> stream line up with the cats on the <code>both$</code> stream? That&#39;s a merge.</p>\n<p>Update the verbs with our merge definition:</p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th>What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td>Merge takes two or more observable streams and <em><strong>combines</strong></em> them together.</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td>?</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"switch\">Switch</h3>\n<p>Last verb on the list is switch.</p>\n<blockquote>\n<p>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the orignal stream at each emission and changes to the new emitted stream.  At every subsequent emission from the root stream, it will stop listening to the previouse child stream. </p>\n</blockquote>\n<p>This is the tougher one of the bunch to understand based off the description, so let&#39;s jump to the cats and the dogs. </p>\n<p>Remember CatConverter? It&#39;s causing a pretty big imbalance in the universe.  Let&#39;s hack that thing. We&#39;re going to change it to an AnimalCloner! This way, any animal that wanders into the machine will get cloned every 100th of a second until the next animal wanders in. What could go wrong? Balance will be restored. </p>\n<pre><code class=\"lang-javascript\">const dogClones$ = Rx.Observable.interval(100).mapTo(&#39;🐶&#39;);\nconst catClones$ = Rx.Observable.interval(100).mapTo(&#39;🐱&#39;);\n\nconst catsAndDogs$ = Rx.Observable.from([\n  dogClones$,\n  dogClones$,\n  catClones$,\n  dogClones$,\n  catClones$,\n]).concatMap(animals$ =&gt; Rx.Observable.of(animals$).delay(1000));\n\nconst AnimalCloner = (animals$) =&gt; animals$;\n\nAnimalCloner(catsAndDogs$);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/6Jrz26JG\">Run this code</a></p>\n<p>First thing to note here is that it does NOT use the switch operator.  And has caused chaos:</p>\n<pre><code class=\"lang-javascript\">|------d$------d$------c$------d$------c$---------&gt;\n       |\n       |-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶&gt;\n                   |\n                   |-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-🐶-&gt;\n                         |\n                         |-🐱-🐱-🐱-🐱-🐱-🐱-🐱-🐱-&gt;\n                                 |\n                                 |-🐶-🐶-🐶-🐶-🐶-🐶&gt;\n                                        |\n                                        |-🐱-🐱-🐱-🐱&gt;\n</code></pre>\n<p>AnimalCloner is out of control. What we want is <em>one</em> stream of animals for each time an animal enters the cloner. Instead we end up with <em>multiple</em> streams. <code>Switch</code> to the rescue, but first we need to make sure we understand why there are multiple streams here.</p>\n<p><code>dogClones$</code>: This is a stream of dogs that emit every 100th of a second</p>\n<p><code>catClones$</code>: This is a stream of cats that emit every 100th of a second</p>\n<p><code>catsAndDogs$</code>: This is a stream that emits a mix of <strong>dogClones$</strong> and <strong>catClones$</strong> every second. The important take-away here is that this is a <strong>stream of streams</strong>.  That&#39;s why when we pass <code>catsAndDogs$</code> into <code>AnimalCloner()</code> we get that nasty barage of streams. What we want is one stream.  And this is exactly what&#39;s missing from the <strong>switch</strong> description:</p>\n<blockquote>\n<p>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the original stream at each emission and change to the new emitted stream.  At <em><strong>every subsequent emission from the root stream, it will stop listening to the previous child stream</strong></em>.  </p>\n</blockquote>\n<p>Let&#39;s add <code>switch()</code>.</p>\n<pre><code class=\"lang-javascript\">const dogClones$ = Rx.Observable.interval(100).mapTo(&#39;🐶&#39;);\nconst catClones$ = Rx.Observable.interval(100).mapTo(&#39;🐱&#39;);\n\nconst catsAndDogs$ = Rx.Observable.from([\n  dogClones$,\n  dogClones$,\n  catClones$,\n  dogClones$,\n  catClones$,\n]).concatMap(animals$ =&gt; Rx.Observable.of(animals$).delay(1000));\n\nconst AnimalCloner = (animals$) =&gt; animals$;\n\nAnimalCloner(catsAndDogs$).switch();\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/38MYm38v\">Run this code</a></p>\n<p>Fixed. Now it&#39;s just one nice stream that <em>switches</em> to the latest dog or cat stream over time. </p>\n<pre><code class=\"lang-javascript\">|------d$------d$------c$------d$------c$---------&gt;\n       |\n       |-🐶-🐶-🐶-🐶-🐱-🐱-🐱-🐶-🐶-🐶--🐱-🐱-🐱&gt;\n</code></pre>\n<p>Update the verbs with our switch definition:</p>\n<table>\n<thead>\n<tr>\n<th>Verb</th>\n<th>What it does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Map</td>\n<td>Use the <em><strong>value of something</strong></em> to change it to <em><strong>something else</strong></em>.</td>\n<td></td>\n</tr>\n<tr>\n<td>Merge</td>\n<td>Merge takes two or more observable streams and <em><strong>combines</strong></em> them together.</td>\n</tr>\n<tr>\n<td>Switch</td>\n<td>Switch operates on a stream where each emission is another stream.  Switch will   stop listening to the original stream at each emission and changes to the new emitted stream.  At every subsequent emission from the root stream, it will stop listening to the previous child stream.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"mergemap-switchmap\">MergeMap &amp; SwitchMap</h3>\n<p>Now that we have all the verbs defined, we can combine the definitions together to understand these two operators. </p>\n<h5 id=\"mergemap\">MergeMap</h5>\n<blockquote>\n<p>MergeMap changes (maps) the values emitted from one stream to a new stream.  It combines (merges) all the new streams into one stream. </p>\n</blockquote>\n<h5 id=\"switchmap\">SwitchMap</h5>\n<blockquote>\n<p>SwitchMap changes (maps) the values emitted from one stream to a new stream.  It stops listening to the previous stream and changes (switches) to the next stream. </p>\n</blockquote>\n<p>Let&#39;s see these in action, but this time I&#39;ll go with a more real-world example.</p>\n<p>Consider a chat app. The app has a list of users that you can click on to begin listening to their messages. At any point, you can click a different user to begin seeing their messages instead. In Observable land, this could look like:</p>\n<pre><code class=\"lang-javascript\">const kim = document.createElement(&#39;input&#39;);\nconst bob = document.createElement(&#39;input&#39;);\noutput.prepend(kim)\noutput.prepend(bob)\n\nkim.setAttribute(&#39;type&#39;, &#39;button&#39;);\nkim.setAttribute(&#39;value&#39;, &#39;kim&#39;);\n\nbob.setAttribute(&#39;type&#39;, &#39;button&#39;);\nbob.setAttribute(&#39;value&#39;, &#39;bob&#39;);\n\nconst chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n).mergeMap((clickEvent) =&gt; Rx.Observable\n   .interval(800)\n   .mapTo(`Hi from ${clickEvent.target.value}`)\n);\n\nchatStream$.map((message) =&gt; message);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/jOLw0Boy\">Run this code</a></p>\n<p>This example attempts to accomplish the chat requirements with <strong>mergeMap</strong>. Stepping through the code, we can understand what&#39;s going on.</p>\n<pre><code class=\"lang-javascript\">const kim = document.createElement(&#39;input&#39;);\nconst bob = document.createElement(&#39;input&#39;);\noutput.prepend(kim)\noutput.prepend(bob)\n\nkim.setAttribute(&#39;type&#39;, &#39;button&#39;);\nkim.setAttribute(&#39;value&#39;, &#39;kim&#39;);\n\nbob.setAttribute(&#39;type&#39;, &#39;button&#39;);\nbob.setAttribute(&#39;value&#39;, &#39;bob&#39;);\n</code></pre>\n<p>This creates the html buttons and gives them a value of either &#39;kim&#39; or &#39;bob&#39;.</p>\n<pre><code class=\"lang-javascript\">\nconst chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n)\n</code></pre>\n<p>This creates two streams and combines them. The streams are (1) clicks from &#39;bob&#39; and (2) clicks from &#39;kim&#39;.</p>\n<pre><code class=\"lang-javascript\">const chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n).mergeMap((clickEvent) =&gt; Rx.Observable\n   .interval(800)\n   .mapTo(`Hi from ${clickEvent.target.value}`)\n);\n</code></pre>\n<p>This <strong>mergeMap()&#39;s</strong> off the stream of clicks. Our definition of mergeMap tells us that it will <strong>change</strong> the value from the first stream of clicks into a <strong>new Observable</strong>.  The new Observable emits a message from the clicked user every 800th of a second. </p>\n<p>Unlike <strong>switchMap</strong>, as clicks are emitted from the first stream, the previous child message stream never actually stops.  They just keep collecting over time! That gets pretty noisy. </p>\n<p>Run the example and switch between bob and kim. You&#39;ll see each time you switch to a different user, the messages pile up. Clearly, we&#39;re not switching - we&#39;re merging!</p>\n<p>We need to switch. Let&#39;s update:</p>\n<pre><code class=\"lang-javascript\">const kim = document.createElement(&#39;input&#39;);\nconst bob = document.createElement(&#39;input&#39;);\noutput.prepend(kim)\noutput.prepend(bob)\n\nkim.setAttribute(&#39;type&#39;, &#39;button&#39;);\nkim.setAttribute(&#39;value&#39;, &#39;kim&#39;);\n\nbob.setAttribute(&#39;type&#39;, &#39;button&#39;);\nbob.setAttribute(&#39;value&#39;, &#39;bob&#39;);\n\nconst chatStream$ = Rx.Observable.merge(\n   Rx.Observable.fromEvent(kim, &#39;click&#39;),\n   Rx.Observable.fromEvent(bob, &#39;click&#39;),\n).switchMap((clickEvent) =&gt; Rx.Observable\n   .interval(800)\n   .mapTo(`Hi from ${clickEvent.target.value}`)\n);\n\nchatStream$.map((message) =&gt; message);\n</code></pre>\n<p><a target=\"_blank\" href=\"https://rxviz.com/v/RoQBxAOM\">Run this code</a></p>\n<p>Switched! Run the example again and observe the new behaviour. It actually switches now. As you change from bob to kim, the stream stops listening to bob and <em><strong>switches</strong></em> to kim.</p>\n"}},"siteProps":{"title":"React Static"}};</script><script async="" src="/app.6ce5e406.js"></script></body></html>